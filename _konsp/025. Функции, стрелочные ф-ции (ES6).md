# 025. Функции, стрелочные ф-ции (ES6)

## 14:16

1. function declaration:

	```javascript
	function foo(){} // Создаётся до начала выполнения скрипта, можно вызвать перед объявлением.
	````

1. function expression:

	```javascript
	let foo = function(){} // Создаётся только тогда, когда доходит поток кода, можно вызвать только после объявления.
	````

1. стрелочные функции: 

	```javascript
	()=>
	````
	Не имеет своего контекста (this).

	пример:
	```javascript
	const calc = (a,b) => a+b;
	const calc = (a,b) => { return a+b; };
	const calc = a => a*2;
	````
	### Синтаксис
	
	Базовый синтаксис:
	
	```javascript
	(param1, param2, …, paramN) => { statements }
	(param1, param2, …, paramN) => expression
	// эквивалентно: '(param1, param2, …, paramN) => { return expression; }'

	// Круглые скобки не обязательны для единственного параметра:
	(singleParam) => { statements }
	singleParam => { statements }

	// Функция без параметров нуждается в круглых скобках:
	() => { statements }
	() => expression
	// Эквивалентно: '() => { return expression; }'

	Расширенный синтаксис:
	// Когда возвращаете литеральное выражение объекта, заключите тело в скобки
	params => ({foo: bar})
	var func = () => { foo: 1 }; // Вызов func() возвращает undefined!

	// Остаточные параметры и параметры по умолчанию поддерживаются
	(param1, param2, ...rest) => { statements }
	(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }

	// Деструктуризация тоже поддерживается
	var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
	f();  // 6
	}
	````

	{

Синтаксис "`new Function`":

> [!CAUTION]
работает только в браузере !

```JavaScript
// Функция создаётся с заданными аргументами arg1...argN и телом functionBody.
let func = new Function([arg1, arg2, ...argN], functionBody);

// Это проще понять на конкретном примере. Здесь объявлена функция с двумя аргументами:
let sum = new Function('a', 'b', 'return a + b');
alert( sum(1, 2) ); // 3

// А вот функция без аргументов, в этом случае достаточно указать только тело:
let sayHi = new Function('alert("Hello")');
sayHi(); // Hello
```
Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, 
что функция создаётся полностью «на лету» из строки, переданной во время выполнения.

Обычно функция запоминает, где родилась, в специальном свойстве [[Environment]]. 

Это ссылка на лексическое окружение (Lexical Environment), в котором она создана (мы разбирали это в главе Замыкание).

Но когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.

##	замыкание:
//		создаётся новый экземпляр "createCounter.counter" из области "область_2" при создании экземпляра "myFunction"
//	на этот экземпляр "createCounter.counter" создаётся замыкание.
//		это похоже на создание экземпляра класса "createCounter", имеющего переменную "counter"
//	и при каждом создании "const переменная = createCounter();" создаётся новый экземпляр класса "createCounter".
//		замыкание происходит в случае, если при выходе из области объявления становятся недоступными переменные, 
//	использующиеся внутри объявления фукции.
//
{ // область "область_1"
	let counter = 10;
	function createCounter() { // область "область_2"
		let counter = 20;
		const myFunction = function() {
			counter = counter + 1;
			return counter;
		};
		return myFunction;
	}
	const inc1 = createCounter();
	const c11 = inc1();
	const c12 = inc1();
	const c13 = inc1();
	console.log('c1*:', c11, c12, c13);
	const inc2 = createCounter();
	const c21 = inc2();
	const c22 = inc2();
	console.log('c2*:', c21, c22);
	console.log('counter', counter);
}
/* результат:
c1*: 21 22 23
c2*: 21 22
counter 10
*/
// =================================================================
//	НЕ замыкание:
//		создаётся ССЫЛКА на экземпляр "counter" из области "область_1" при создании экземпляра "myFunction"
//	( ближайшая предыдущая относительно "const myFunction = function() {" область, 
//	в которой присутствует переменная "counter" ).
//		при каждом создании экземпляра "const myFunction = function() {"
//	ссылается на один и тот же экземпляр "counter" из области "область_1".
//
{ // область "область_1"
	let counter = 10;
	function createCounter() { // область "область_2"
		//let counter = 20;
		const myFunction = function() {
			counter = counter + 1;
			return counter;
		};
		return myFunction;
	}
	const inc1 = createCounter();
	const c11 = inc1();
	const c12 = inc1();
	const c13 = inc1();
	console.log('c1*:', c11, c12, c13);
	const inc2 = createCounter();
	const c21 = inc2();
	const c22 = inc2();
	console.log('c2*:', c21, c22);
	console.log('counter', counter);
}
/* результат:
c1*: 11 12 13
c2*: 14 15
counter 15
*/
	}
	{
// 025_31
// пример того, что создаётся ссылка на имеющийся экземпляр переменной "getCounter.counter"
'use strict';

function getCounter(){
	let counter = 10;

	const fCnr1 = ()=> ++counter;
	const fCnr2 = ()=> ++counter;

	return {fCnr1, fCnr2};
}

{
	const fInc_1 = getCounter();
	const inc_11 = fInc_1.fCnr1;
	const inc_12 = fInc_1.fCnr2;

	const c1_11 = inc_11(); // 11
	const c1_12 = inc_11(); // 12
	const c1_21 = inc_12(); // 13
	const c1_13 = inc_11(); // 14
	const c1_22 = inc_12(); // 15

	console.log('c1_1*:', c1_11, c1_12, c1_13);
	console.log('c1_2*:', c1_21, c1_22);
}
{
	const fInc_2 = getCounter();
	const inc_21 = fInc_2.fCnr1;
	const inc_22 = fInc_2.fCnr2;
	const c2_11 = inc_21(); // 11
	const c2_12 = inc_21(); // 12
	const c2_21 = inc_22(); // 13
	const c2_13 = inc_21(); // 14
	const c2_22 = inc_22(); // 15

	console.log('c2_1*:', c2_11, c2_12, c2_13);
	console.log('c2_2*:', c2_21, c2_22);
}
/* результат:
c1_1*: 11 12 14
c1_2*: 13 15
c2_1*: 11 12 14
c2_2*: 13 15
*/
	}
	{
замыкание
https://learn.javascript.ru/closure

Лексическое Окружение:
Чтобы понять, что происходит, давайте для начала обсудим, что такое «переменная» на самом деле.
В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний 
(скрытый) объект, называемый лексическим окружением LexicalEnvironment.
Объект лексического окружения состоит из двух частей:
	1. Environment Record – объект, в котором как свойства хранятся все локальные переменные 
		(а также некоторая другая информация, такая как значение this).
	2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи 
		(снаружи от текущих фигурных скобок).
"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. 
«Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

Итого:
* Переменная – это свойство специального внутреннего объекта, связанного с текущим 
		выполняющимся блоком/функцией/скриптом.
* Работа с переменными – это на самом деле работа со свойствами этого объекта.

Внутреннее и внешнее лексическое окружение:
	При запуске функции для неё автоматически создаётся новое лексическое окружение, 
для хранения локальных переменных и параметров вызова.
	Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем 
лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.
	Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, 
для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную 
переменную с таким именем.

"информация":
Один вызов – одно лексическое окружение:
	Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, 
когда функция выполняется.
	И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, 
со своими, специфичными для этого вызова, локальными переменными и параметрами.

"информация":
Лексическое окружение – это специальный внутренний объект:
	«Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем 
коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые 
переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта 
должно оставаться таким, как было описано.
	}

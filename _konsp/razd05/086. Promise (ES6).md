# 086. Promise (ES6)

## `Promise`
> Объект `Promise` используется для отложенных и асинхронных вычислений.

- Синтаксис
	```javascript
	new Promise(executor);
	new Promise(function(resolve, reject) { ... });
	```
- Параметры
	- `executor`
		- Объект функции с двумя аргументами `resolve` и `reject`. Функция `executor` получает оба аргумента и выполняется сразу, ещё до того как конструктор вернёт созданный объект. Первый аргумент (`resolve`) вызывает успешное исполнение промиса, второй (`reject`) отклоняет его. Обычно функция `executor` описывает выполнение какой-то асинхронной работы, по завершении которой необходимо вызвать функцию `resolve` или `reject`. Обратите внимание, что возвращаемое значение функции `executor` игнорируется.
- Описание
	- Интерфейс `Promise` (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "промис") получить результат в некоторый момент в будущем.
	- `Promise` может находиться в трёх состояниях:
		1. ожидание (`pending`): начальное состояние, не исполнен и не отклонён.
  		1. исполнено (`fulfilled`): операция завершена успешно.
    	1. отклонено (`rejected`): операция завершена с ошибкой.
	- При создании промис находится в ожидании (`pending`), а затем может стать исполненным (`fulfilled`), вернув полученный результат (значение), или отклонённым (`rejected`), вернув причину отказа. В любом из этих случаев вызывается обработчик, прикреплённый к промису методом `then`. 
		>(Если в момент назначения обработчика промис уже исполнен или отклонён, обработчик всё равно будет вызван, т.е. асинхронное исполнение промиса и назначение обработчика не будет происходить в «состоянии гонки», как, например, в случае с событиями в DOM.)
	- Так как методы `Promise.prototype.then()` и `Promise.prototype.catch()` сами возвращают промис, их можно вызывать цепочкой, создавая соединения.
- Методы
	- `Promise.all(iterable)`
		- Ожидает исполнения всех промисов или отклонения любого из них.
		- Возвращает промис, который исполнится после исполнения всех промисов в `iterable`. В случае, если любой из промисов будет отклонён, `Promise.all` будет также отклонён.
	- `Promise.allSettled(iterable)`
		- Ожидает завершения всех полученных промисов (как исполнения так и отклонения).
		- Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.
	- `Promise.race(iterable)`
		- Ожидает исполнения или отклонения любого из полученных промисов.
		- Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из `iterable`.
	- `Promise.reject(reason)`
		- Возвращает промис, отклонённый из-за `reason`.
	- `Promise.resolve(value)`
		- Возвращает промис, исполненный с результатом `value`.
---

## Создание промиса

Объект `Promise` создаётся при помощи ключевого слова `new` и своего конструктора. Конструктор `Promise` принимает в качестве аргумента функцию, называемую "исполнитель" (executor function). Эта функция должна принимать две функции-колбэка в качестве параметров. Первый из них (`resolve`) вызывается, когда асинхронная операция завершилась успешно и вернула результат своего исполнения в виде значения. Второй колбэк (`reject`) вызывается, когда операция не удалась, и возвращает значение, указывающее на причину неудачи, чаще всего объект ошибки.
```javascript
const myFirstPromise = new Promise((resolve, reject) => {
	// выполняется асинхронная операция, которая в итоге вызовет:
	//
	//   resolve(someValue); // успешное завершение
	// или
	//   reject("failure reason"); // неудача
});
```

```javascript
let promise = new Promise( (resolve, reject) => {
	// эта функция выполнится автоматически, при вызове new Promise

	// через 1 секунду сигнализировать, что задача выполнена с результатом "done"
	setTimeout(() => resolve("done"), 1000);
});
```

```javascript
let promise = new Promise(function(resolve, reject) {
	// спустя одну секунду будет сообщено, что задача выполнена с ошибкой
	setTimeout(() => reject(new Error("Whoops!")), 1000);
});
```

## Потребители: `then`, `catch`

Объект `Promise` служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then` и `.catch`.

## `then`

Наиболее важный и фундаментальный метод – `.then`.

Синтаксис:
```javascript
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```
Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

## `catch`

Если мы хотели бы только обработать ошибку, то можно использовать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Или можно воспользоваться методом `.catch(errorHandlingFunction)`, который сделает то же самое:
```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```
Вызов `.catch(f)` – это сокращённый, «укороченный» вариант .`then(null, f)`.

---

```javascript
const fOk      = function (_data) { console.log('fOk='     , _data); };
const fErr     = function (_data) { console.log('fErr='    , _data); };
const fCatch   = function (_data) { console.log('fCatch='  , _data); };
const fFinally = function (_data) { console.log('fFinally=', _data); };

const myPromise = _data => {
	return new Promise( (_fOk, _fErr) => {
		let vResult = false;
		// какие-то действия, результат которых будет записан в vResult
		if (vResult) _fOk(vResult)
		else  _fErr(vResult);
	});
};

myPromise()
//.then(fOk, fErr) // усли в .then() не указана fErr, то в случае ошибки вызовется .catch()
.then(fOk)
.catch(fCatch)
.finally(fFinally);
/* result:
fCatch= false
fFinally= undefined
*/
```
---

## `Async`/`await`

> Существует специальный синтаксис для работы с промисами, который называется `«async`/`await»`. Он удивительно прост для понимания и использования.

## Асинхронные функции

Начнём с ключевого слова `async`. Оно ставится перед функцией, вот так:
```javascript

async function f() {
  return 1;
}
```
У слова `async` один простой смысл: эта функция всегда возвращает `промис`. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:
```javascript
async function f() {
  return 1;
}

f().then(alert); // 1
```
Так что ключевое слово `async` перед функцией гарантирует, что эта функция в любом случае вернёт `промис`. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – `await`, которое можно использовать только внутри `async`-функций.

## `Await`

Синтаксис:
```javascript
// работает только внутри async–функций
let value = await promise;
```
Ключевое слово `await` заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от `await` не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:
```javascript
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
```
В данном примере выполнение функции остановится на строке `(*)` до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя `await` и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем `promise.then`.

## `await` нельзя использовать в обычных функциях

-	Если мы попробуем использовать `await` внутри функции, объявленной без `async`, получим синтаксическую ошибку:
	```javascript
	function f() {
	  let promise = Promise.resolve(1);
	  let result = await promise; // SyntaxError
	}
	```
	Ошибки не будет, если мы укажем ключевое слово `async` перед объявлением функции. Как было сказано раньше, `await` можно использовать только внутри `async–функций`.

Давайте перепишем пример `showAvatar()` из раздела Цепочка промисов с помощью `async`/`await`:

1.    Нам нужно заменить вызовы .then на await.
1.    И добавить ключевое слово async перед объявлением функции.
```javascript
async function showAvatar() {

  // запрашиваем JSON с данными пользователя
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // запрашиваем информацию об этом пользователе из github
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // отображаем аватар пользователя
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // ждём 3 секунды и затем скрываем аватар
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```
Получилось очень просто и читаемо, правда? Гораздо лучше, чем раньше.

## `await` нельзя использовать на верхнем уровне вложенности

- Программисты, узнав об `await`, часто пытаются использовать эту возможность на верхнем уровне вложенности (вне тела функции). Но из-за того, что `await` работает только внутри `async–функций`, так сделать не получится:
	```javascript
	// SyntaxError на верхнем уровне вложенности
	let response = await fetch('/article/promise-chaining/user.json');
	let user = await response.json();
	```
	Можно обернуть этот код в анонимную async–функцию, тогда всё заработает:
	```javascript
	(async () => {
	  let response = await fetch('/article/promise-chaining/user.json');
	  let user = await response.json();
	  ...
	})();
	```

---

## Ссылки

- Промисы
	- https://learn.javascript.ru/promise-basics
- Promise
	- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise
- наглядный пример
	- https://stasonmars.ru/javascript/promisy-v-javascript-dlya-chainikov/

# 100. Инкапсуляция

## Инкапсуляция, полиморфизм, наследование

## 1. Инкапсуляция

Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. В объектно-ориентированном программировании код и данные могут быть объединены вместе; в этом случае говорят, что создаётся так называемый "чёрный ящик". Когда коды и данные объединяются таким способом, создаётся объект (object). Другими словами, объект - это то, что поддерживает инкапсуляцию.

Внутри объекта коды и данные могут быть закрытыми (private). Закрытые коды или данные доступны только для других частей этого объекта. Таким образом, закрытые коды и данные недоступны для тех частей программы, которые существуют вне объекта. Если коды и данные являются открытыми, то, несмотря на то, что они заданы внутри объекта, они доступны и для других частей программы. Характерной является ситуация, когда открытая часть объекта используется для того, чтобы обеспечить контролируемый интерфейс закрытых элементов объекта.

На самом деле объект является переменной определённого пользователем типа. Может показаться странным, что объект, который объединяет коды и данные, можно рассматривать как переменную. Однако применительно к объектно-ориентированному программированию это именно так. Каждый элемент данных такого типа является составной переменной.

## 2. Полиморфизм

Полиморфизм (polymorphism) (от греческого polymorphos) - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Целью полиморфизма, применительно к объектно-ориентированному программированию, является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. Например для языка Си, в котором полиморфизм поддерживается недостаточно, нахождение абсолютной величины числа требует трёх различных функций: abs(), labs() и fabs(). Эти функции подсчитывают и возвращают абсолютную величину целых, длинных целых и чисел с плавающей точкой соответственно. В С++ каждая из этих функций может быть названа abs(). Тип данных, который используется при вызове функции, определяет, какая конкретная версия функции действительно выполняется. В С++ можно использовать одно имя функции для множества различных действий. Это называется перегрузкой функций (function overloading).

В более общем смысле, концепцией полиморфизма является идея "один интерфейс, множество методов". Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование того же интерфейса для задания единого класса действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор. Вам, как программисту, не нужно делать этот выбор самому. Нужно только помнить и использовать общий интерфейс. Пример из предыдущего абзаца показывает, как, имея три имени для функции определения абсолютной величины числа вместо одного, обычная задача становится более сложной, чем это действительно необходимо.

Полиморфизм может применяться также и к операторам. Фактически во всех языках программирования ограниченно применяется полиморфизм, например, в арифметических операторах. Так, в Си, символ + используется для складывания целых, длинных целых, символьных переменных и чисел с плавающей точкой. В этом случае компилятор автоматически определяет, какой тип арифметики требуется. В С++ вы можете применить эту концепцию и к другим, заданным вами, типам данных. Такой тип полиморфизма называется перегрузкой операторов (operator overloading).

Ключевым в понимании полиморфизма является то, что он позволяет вам манипулировать объектами различной степени сложности путём создания общего для них стандартного интерфейса для реализации похожих действий.

## 3. Наследовние

Наследование (inheritance) - это процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Наследование является важным, поскольку оно позволяет поддерживать концепцию иерархии классов (hierarchical classification). Применение иерархии классов делает управляемыми большие потоки информации. Например, подумайте об описании жилого дома. Дом - это часть общего класса, называемого строением. С другой стороны, строение - это часть более общего класса - конструкции, который является частью ещё более общего класса объектов, который можно назвать созданием рук человека. В каждом случае порождённый класс наследует все, связанные с родителем, качества и добавляет к ним свои собственные определяющие характеристики. Без использования иерархии классов, для каждого объекта пришлось бы задать все характеристики, которые бы исчерпывающи его определяли. Однако при использовании наследования можно описать объект путём определения того общего класса (или классов), к которому он относится, с теми специальными чертами, которые делают объект уникальным. Наследование играет очень важную роль в OOP. 

---

## Новые #приватные поля классов в JavaScript

Приватные поля классов в процессе стандартизации JavaScript добрались до Stage 2. Это еще не финальная стадия, но комитет по стандартам JavaScript ожидает, что эта возможность будет разработана и в конечном итоге включена в стандарт (хотя она все еще может измениться).

Синтаксис (в настоящее время) выглядит так:
```javascript
class Point {
  #x;
  #y;  constructor(x, y) {
    this.#x = x;
    this.#y = y;
  }  equals(point) {
    return this.#x === point.#x && this.#y === point.#y;
  }
}
```

В этом синтаксисе есть две важные части:
1. Объявление приватных полей;
1. Обращение к приватным полям.

## Объявление приватных полей

Объявление приватных полей в основном совпадает с объявлением публичных полей:
```javascript
class Foo {
  publicFieldName = 1;
  #privateFieldName = 2;
}
```

## Обращение к приватным полям

Ссылка на приватные поля работает аналогично доступу к любому другому свойству, только она имеет специальный синтаксис.
```javascript
class Foo {
  publicFieldName = 1;
  #privateFieldName = 2;
  add() {
    return this.publicFieldName + this.#privateFieldName;
  }
}
```

Также есть краткая форма записи для `this.#`:
```javascript
method() {
  #privateFieldName;
}
```

Это то же самое, что:
```javascript
method() {
  this.#privateFieldName;
}
```

## Обращение к приватным полям экземпляров класса

Обращение к приватным полям не ограничивается `this`. Вы также можете получить доступ к приватным полям экземпляров вашего класса:
```javascript
class Foo {
  #privateValue = 42;
  static getPrivateValue(foo) {
    return foo.#privateValue;
  }
}
Foo.getPrivateValue(new Foo()); // >> 42
```
Здесь `foo` является экземпляром `Foo`, поэтому нам разрешено обращаться к `#privateValue` из описания класса.

## Приватные методы (скоро будут?)

Приватные поля являются частью предложения, посвященного добавлению полей классов. Предложение не вносит никаких изменений в методы класса, поэтому приватные методы класса ожидаются в следующем предложении и, скорее всего, будут выглядеть следующим образом:
```javascript
class Foo {
  constructor() {
    this.#method();
  }
  #method() {
    // ...
  }
}
```
Тем временем вы все равно можете присваивать приватным полям функции:
```javascript
class Foo {
  constructor() {
    this.#method();
  }  #method = () => {
    // ...
  };
}
```

---

```javascript
'use strict';

class User {
	#age;

	constructor(_name, _age) {
		this.name = _name;
		this.#age = _age;
	}

	// стрелочная функция получает this - экземпляр класса
	say = () => {
		console.log(`Имя пользователя: ${this.name}, возраст ${this.#age}`);
	};

	get age() { return this.#age; }

	set age(_age) {
		if (typeof (_age) === 'number' && _age > 0 && _age < 100) {
			this.#age = _age;
		} else {
			console.log('Недопустимое значение');
		}
	}
}

const ivan = new User('Ivan', 27);
console.log( ivan.age );
ivan.age = 99;
ivan.age = 300;
console.log( ivan.age );
ivan.say();
/*
27
Недопустимое значение
99
Имя пользователя: Ivan, возраст 99
*/
```

---

## Ссылки

- Инкапсуляция, полиморфизм, наследование
	- www.codenet.ru/progr/cpp/ipn.php
- Новые #приватные поля классов в JavaScript
	- https://medium.com/devschacht/javascripts-new-private-class-fields-c60daffe361b

# 115. Макро и микрозадачи

> `Макрозадачи` это задачи, не попадающие в `Микрозадачи`

## Микрозадачи

Помимо макрозадач, описанных в этой части, существуют микрозадачи, упомянутые в главе [Микрозадачи](https://learn.javascript.ru/microtask-queue).

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика `.then`/`catch`/`finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Также есть специальная функция `queueMicrotask(func)`, которая помещает `func` в очередь микрозадач.

>Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

Например:
```javascript
setTimeout( () => alert("timeout") );

Promise.resolve()
  .then( () => alert("promise") );

alert("code");
```

Какой здесь будет порядок?
1. `code` появляется первым, т.к. это обычный синхронный вызов.
2. `promise` появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3. `timeout` появляется последним, потому что это макрозадача.

## Итого

Более подробный алгоритм событийного цикла (хоть и упрощённый в сравнении со [спецификацией](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)):

1. Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
2. Исполнить все микрозадачи:
	- Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
3. Отрисовать изменения страницы, если они есть.
4. Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5. Перейти к шагу 1.

Чтобы добавить в очередь новую макрозадачу:
- Используйте `setTimeout(f)` с нулевой задержкой.

Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).

Для добавления в очередь новой микрозадачи:
- Используйте `queueMicrotask(f)`.
- Также обработчики промисов выполняются в рамках очереди микрозадач.

События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому `queueMicrotask` можно использовать для асинхронного выполнения функции в том же состоянии окружения.

## Web Workers

Для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл, мы можем использовать [Web Workers](https://html.spec.whatwg.org/multipage/workers.html).

Это способ исполнить код в другом, параллельном потоке.

Web Workers могут обмениваться сообщениями с основным процессом, но они имеют свои переменные и свой событийный цикл.

Web Workers не имеют доступа к DOM, поэтому основное их применение – вычисления. Они позволяют задействовать несколько ядер процессора одновременно.

---

## Ссылки

- Событийный цикл: микрозадачи и макрозадачи
	- https://learn.javascript.ru/event-loop
	- https://learn.javascript.ru/microtask-queue

# 163. useState

## `useState`

```javascript
const [state, setState] = useState(initialState);
```

Возвращает значение с состоянием и функцию для его обновления.

Во время первоначального рендеринга возвращаемое состояние (`state`) совпадает со значением, переданным в качестве первого аргумента (`initialState`).

Функция `setState` используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента.
```javascript
setState(newState);
```

Во время последующих повторных рендеров первое значение, возвращаемое `useState`, всегда будет самым последним состоянием после применения обновлений.

> Примечание
>
> React гарантирует, что идентичность функции `setState` стабильна и не изменяется при повторных рендерах. Поэтому её можно безопасно не включать в списки зависимостей хуков `useEffect` и `useCallback`.

## Функциональные обновления

Если новое состояние вычисляется с использованием предыдущего состояния, вы можете передать функцию в `setState`. Функция получит предыдущее значение и вернёт обновлённое значение. Вот пример компонента счётчик, который использует обе формы `setState`:
```javascript
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Счёт: {count}
      <button onClick={() => setCount(initialCount)}>Сбросить</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
    </>
  );
}
```

Кнопки «+» и «-» используют функциональную форму, потому что обновлённое значение основано на предыдущем значении. Но кнопка «Сбросить» использует обычную форму, потому что она всегда устанавливает счётчик обратно в 0.

Если функция обновления возвращает абсолютно такой же результат как и текущее состояние, то последующие повторные рендеры будут полностью пропущены.

> Примечание
>
> В отличие от метода `setState`, который вы можете найти в классовых компонентах, `useState` не объединяет объекты обновления автоматически. Вы можете повторить это поведение, комбинируя форму функции обновления с синтаксисом расширения объекта:
```javascript
    const [state, setState] = useState({});
    setState(prevState => {
      // Object.assign также будет работать
      return {...prevState, ...updatedValues};
    });
```
> Другой вариант — `useReducer`, который больше подходит для управления объектами состояния, содержащими несколько значений.

## Ленивая инициализация состояния

Аргумент `initialState` — это состояние, используемое во время начального рендеринга. В последующих рендерах это не учитывается. Если начальное состояние является результатом дорогостоящих вычислений, вы можете вместо этого предоставить функцию, которая будет выполняться только при начальном рендеринге:
```javascript
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

## Досрочное прекращение обновления состояния

Если вы обновите состояние хука тем же значением, что и текущее состояние, React досрочно выйдет из хука без повторного рендера дочерних элементов и запуска эффектов. (React использует [алгоритм сравнения Object.is.](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description))

Обратите внимание, что для React всё ещё может быть необходим повторный рендер этого компонента. Это не должно быть проблемой, потому что React не будет сильно «углубляться» в дерево. Если вы делаете дорогостоящие вычисления во время рендеринга, вы можете оптимизировать их с помощью `useMemo`.

## Группировка обновлений состояния

React может группировать несколько обновлений состояния в один повторный рендер для улучшения производительности. Обычно это улучшает производительность и не должно влиять на поведение вашего приложения.

До 18 версии React группировал только обновления внутри обработчиков событий. Начиная с 18 версии, группировка включена по умолчанию для всех обновлений. Обратите внимание, что если обновления вызваны несколькими различными действиями пользователя — например, пользователь дважды кликнул на кнопку — то они обрабатываются раздельно и не будут сгруппированы. Это позволяет избежать логических ошибок.

В редких случаях, когда вам нужно вызвать принудительное синхронное обновление DOM, вы можете обернуть его в [flushSync](https://ru.legacy.reactjs.org/docs/react-dom.html#flushsync). Однако это может вызвать ухудшение производительности, используйте это только в тех случаях, где это действительно нужно.

---

## Ссылки

- useState - Использование хука состояния
	- https://ru.legacy.reactjs.org/docs/hooks-reference.html#usestate
	- https://ru.legacy.reactjs.org/docs/hooks-state.html
- задание
	- https://codepen.io/ihinstone/pen/QWvYePv
- решение
	- https://codepen.io/ihinstone/pen/JjJKVmW
- starter.zip
	- https://drive.google.com/file/d/1V_TZbTFLILgTEIvdLKGk06zPpaHO2ZPw/view
- (EN) useState
	- https://react.dev/reference/react/useState
- (RU) useState()
	- https://reactdev.ru/types/052/#usestate

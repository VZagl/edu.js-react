# 172. (д) `useTransition`, `useDeferredValue` и другие нововведения React 18+

## введение в конкурентный режим

## Представляем параллельный режим (экспериментальный)

> Осторожно:
>
> Эта страница несколько устарела и существует только для исторических целей.
>
> React 18 был выпущен с поддержкой параллелизма. Однако «режима» больше нет, а новое поведение полностью опционально и включается только при использовании новых функций .
>
> Подробнее о параллельных API в React 18 см.:
>
> - React.Suspens
> - React.startTransition
> - React.useTransition
> - React.useDeferredValue
>
> Остальная часть этой страницы содержит устаревший, неработающий или неправильный контент.

## Что такое параллельный режим?

> Осторожность:
>
> Это объяснение устарело. В React 18 отказались от стратегии отдельного «режима». Вместо этого параллельный рендеринг включается только при использовании параллельных функций.

Параллельный режим — это набор новых функций, которые помогают приложениям React оставаться отзывчивыми и изящно подстраиваться под возможности устройства пользователя и скорость сети.

Эти функции все еще являются экспериментальными и могут быть изменены. Они еще не являются частью стабильной версии React, но вы можете попробовать их в экспериментальной сборке.

---

## `useId` - хук создан для создателей сторонних библиотек для реакт

`useId` — это React Hook для создания уникальных идентификаторов, которые можно передать атрибутам доступности.

```javascript
const id = useId();
```

useId()
Вызовите `useId` на верхнем уровне вашего компонента, чтобы сгенерировать уникальный идентификатор:

```javascript
import { useId } from 'react';

function PasswordField() {
	const passwordHintId = useId();
	// ...
}
```

- Параметры
  - `useId` не принимает никаких параметров.
- Возвращает
  - `useId` возвращает уникальную строку идентификатора, связанную с этим конкретным useIdвызовом в этом конкретном компоненте.

> **Предостережения**:
>
> `useId` является хуком, поэтому вы можете вызывать его только на верхнем уровне вашего компонента или ваших собственных хуков. Вы не можете вызывать его внутри циклов или условий. Если вам это нужно, извлеките новый компонент и переместите в него состояние.
>
> `useId` не следует использовать для генерации ключей в списке. Ключи должны быть сгенерированы из ваших данных.

---

## `useDeferredValue`

`useDeferredValue` — это React Hook, который позволяет вам отложить обновление части пользовательского интерфейса.

```javascript
const deferredValue = useDeferredValue(value);
```

- Ссылка

  - `useDeferredValue(value)`

  Вызовите `useDeferredValue` на верхнем уровне вашего компонента, чтобы получить отложенную версию этого значения.

  ```javascript
  import { useState, useDeferredValue } from 'react';

  function SearchPage() {
  	const [query, setQuery] = useState('');
  	const deferredQuery = useDeferredValue(query);
  	// ...
  }
  ```

- Параметры

  - `value`: значение, которое вы хотите отложить. Он может иметь любой тип.

- Возвращает

  - Во время первоначального рендеринга возвращаемое отложенное значение будет таким же, как и предоставленное вами значение. Во время обновлений React сначала попытается выполнить повторный рендеринг со старым значением (поэтому он вернет старое значение), а затем попытается выполнить еще один повторный рендеринг в фоновом режиме с новым значением (поэтому он вернет обновленное значение).

- Предостережения

  - Значения, которые вы передаете, `useDeferredValue` должны быть либо примитивными значениями (например, строками и числами), либо объектами, созданными вне рендеринга. Если вы создадите новый объект во время рендеринга и сразу же передадите его в `useDeferredValue`, он будет отличаться при каждом рендеринге, что вызовет ненужную повторную визуализацию фона.

  - Когда `useDeferredValue` получает другое значение (по сравнению с Object.is), в дополнение к текущему рендерингу (когда он все еще использует предыдущее значение) он планирует повторный рендеринг в фоновом режиме с новым значением. Фоновый повторный рендеринг можно прервать: если есть еще одно обновление для `value`, React перезапустит фоновый повторный рендеринг с нуля. Например, если пользователь вводит ввод быстрее, чем диаграмма, получающая отложенное значение, может повторно отобразиться, диаграмма будет повторно отображаться только после того, как пользователь перестанет печатать.

  - `useDeferredValue` интегрируется с [\<Suspense>](https://react.dev/reference/react/Suspense). Если фоновое обновление, вызванное новым значением, приостанавливает работу пользовательского интерфейса, пользователь не увидит откат. Они будут видеть старое отложенное значение, пока данные не загрузятся.

  - `useDeferredValue` сам по себе не предотвращает дополнительные сетевые запросы.

  - Нет фиксированной задержки, вызванной `useDeferredValue` самой собой. Как только React завершит первоначальный повторный рендеринг, React немедленно начнет работать над фоновым повторным рендерингом с новым отложенным значением. Любые обновления, вызванные событиями (например, вводом текста), прерывают повторную визуализацию фона и получают приоритет над ней.

  - Повторный рендеринг фона, вызванный `useDeferredValue` эффектами, не срабатывает до тех пор, пока он не будет зафиксирован на экране. Если повторный рендеринг фона приостанавливается, его эффекты будут запущены после загрузки данных и обновления пользовательского интерфейса.

---

## `useTransition`

`useTransition` — это React Hook, который позволяет вам обновлять состояние, не блокируя пользовательский интерфейс.

```javascript
const [isPending, startTransition] = useTransition();
```

- Ссылка

  - `useTransition()`

  Вызовите `useTransition` на верхнем уровне вашего компонента, чтобы пометить некоторые обновления состояния как переходы.

  ```javascript
  import { useTransition } from 'react';

  function TabContainer() {
  	const [isPending, startTransition] = useTransition();
  	// ...
  }
  ```

- Параметры

  - `useTransition` не принимает никаких параметров.

- Возвращает

  - `useTransition` возвращает массив ровно из двух элементов:

    1. Флаг `isPending`, указывающий, есть ли ожидающий переход.

    2. Функция `startTransition`, позволяющая отметить обновление состояния как переход.

### `startTransition` функция

Функция `startTransition`, возвращаемая `useTransition` позволяет пометить обновление состояния как переход.

```javascript
function TabContainer() {
	const [isPending, startTransition] = useTransition();
	const [tab, setTab] = useState('about');

	function selectTab(nextTab) {
		startTransition(() => {
			setTab(nextTab);
		});
	}
	// ...
}
```

---

## Ссылки

- введение в конкурентный режим
  - https://17.reactjs.org/docs/concurrent-mode-intro.html
- The Plan for React 18
  - https://ru.legacy.reactjs.org/blog/2021/06/08/the-plan-for-react-18.html
- json-generator
  - https://json-generator.com
- список изменений
  - https://github.com/facebook/react/blob/main/CHANGELOG.md
- useDeferredValue
  - https://react.dev/reference/react/useDeferredValue
- useTransition
  - https://react.dev/reference/react/useTransition

# 176. Динамические импорты и React.lazy

## `React.lazy`

> !!!
>
> Динамические (lazy) импорты должна быть после статических import-ов в js-скриптах.

`React.lazy()` позволяет вам определять компонент, который загружается динамически. Это помогает уменьшить размер сборки, откладывая загрузку компонентов, которые не используются во время первоначального рендера.

Вы можете узнать, как этим пользоваться из нашей [документации по разделению кода](https://ru.legacy.reactjs.org/docs/code-splitting.html#reactlazy). Вы также можете посмотреть [эту статью](https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d) с объяснением, как использовать этот метод более подробно.

```javascript
// Этот компонент загружается динамически
const SomeComponent = React.lazy(() => import('./SomeComponent'));
```

Обратите внимание, для рендера `lazy` компонентов требуется чтобы выше в дереве находился компонент `<React.Suspense>`. Это позволит вам отображать индикатор загрузки.

---

## `React.Suspense`

`React.Suspense` позволяет показать индикатор загрузки в случае, если некоторые компоненты в дереве под ним ещё не готовы к рендеру. В будущем мы планируем позволить `Suspense` обрабатывать больше сценариев, таких как получение данных от API.

Сегодня ленивая загрузка компонентов — это **единственный** вариант использования, поддерживаемый `<React.Suspense>`:

```javascript
// Этот компонент загружается динамически
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
	return (
		// Отобразится <Spinner> до тех пор, пока не загрузится <OtherComponent />
		<React.Suspense fallback={<Spinner />}>
			<div>
				<OtherComponent />
			</div>
		</React.Suspense>
	);
}
```

Обратите внимание, что `lazy` компоненты могут быть глубоко внутри дерева `Suspense` — не нужно оборачивать каждый из них. Считается хорошей практикой использовать `<Suspense>` для индикации загрузки, а `lazy()` — для разделения кода.

> Примечание
>
> Если контент уже доступен пользователю, переключение обратно на индикатор загрузки может его дезориентировать. Иногда лучше показать «старый» интерфейс, пока происходит подготовка нового UI. Для этого можно использовать новое API [startTransition](https://ru.legacy.reactjs.org/docs/react-api.html#starttransition) и [useTransition](https://ru.legacy.reactjs.org/docs/hooks-reference.html#usetransition) для работы с переходами, чтобы пометить обновления как переходы и избежать незапланированных откатов.

---

## `import`

Инструкция import используется для импорта ссылок на значения, экспортированные из внешнего модуля. Импортированные модули находятся в строгом режиме независимо от того, объявляете ли вы их как таковые или нет. Для работы инструкции во встроенных скриптах нужно прописать у тэга script `type="module"`.

Существует также function-like динамический `import()`, который не требует скриптов с типом `"module"`.

Обратная совместимость может быть обеспечена с помощью атрибута `nomodule` тега [script](https://developer.mozilla.org/ru/docs/Web/HTML/Element/script).

Динамический импорт полезен в ситуациях, когда вы хотите загрузить модуль условно или по требованию. Статическая форма предпочтительна для загрузки начальных зависимостей и может быть более полезна для инструментов статического анализа и [tree shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)

- Синтаксис
  ```javascript
  import defaultExport from "module-name";
  import * as nameSpace from "module-name";
  import { export } from "module-name";
  import { export as alias } from "module-name";
  import { export1, export2 } from "module-name";
  import { export1, export2 as alias2 , […] } from "module-name";
  import defaultExport, { export [ , […] ] } from "module-name";
  import defaultExport, * as name from "module-name";
  import "module-name";
  import("/module-name.js").then(module => {…}) // Динамический импорт
  ```
- `defaultExport`
  - Имя объекта, который будет ссылаться на значение экспорта по умолчанию (дефолтный экспорт) из модуля.
- `module-name`
  - Имя модуля для импорта. Это зачастую относительный или абсолютный путь к .js файлу модуля без указания расширения .js. Некоторые сборщики могут разрешать или даже требовать использования расширения; проверяйте своё рабочее окружение. Допускаются только строки с одиночными или двойными кавычками.
- `nameSpace`
  - Имя локального объекта, который будет использован как своего рода пространство имён, ссылающееся на импортируемые значения.
- `export, exportN`
  - Имена значений, которые будут импортированы.
- `alias, aliasN`
  - Имена, которые будут ссылаться на импортируемые значения.

## Импорт всего содержимого модуля

Этот код вставляет объект `myModule` в текущую область видимости, содержащую все экспортированные значения из модуля, находящегося в файле `/modules/my-module.js`.

```javascript
import * as myModule from '/modules/my-module.js';
```

В данном случае, доступ к импортируемым значениям можно осуществить с использованием имени модуля (в данном случае "myModule") в качестве пространства имён. Например, если импортируемый выше модуль включает в себя экспорт метода `doAllTheAmazingThings()`, вы можете вызвать его так:

```javascript
myModule.doAllTheAmazingThings();
```

---

## Динамический импорт

Ключевое слово `import` можно использовать как функцию для динамического импорта модулей. Вызов `import()` возвращает Promise.

```javascript
import('/modules/my-module.js').then((module) => {
	// Делаем что-нибудь с модулем
});
```

Как следствие возврата `Promise`, с динамическим импортом можно использовать ключевое слово `await`

```javascript
let module = await import('/modules/my-module.js');
```

Обратите внимание, что несмотря на то, что динамический импорт выглядит как вызов функции, он им по сути не является, т.е. не наследует от `Function.prototype` и, как следствие, его невозможно использовать вместе с методами `.call`, `.apply` и `.bind`

## Примеры

Импорт из вспомогательного модуля для помощи в обработке запроса AJAX JSON.

file.js:

```javascript
function getJSON(url, callback) {
	let xhr = new XMLHttpRequest();
	xhr.onload = function () {
		callback(this.responseText);
	};
	xhr.open('GET', url, true);
	xhr.send();
}

export function getUsefulContents(url, callback) {
	getJSON(url, (data) => callback(JSON.parse(data)));
}
```

main.js:

```javascript
import { getUsefulContents } from '/modules/file.js';

getUsefulContents('http://www.example.com', (data) => {
	doSomethingUseful(data);
});
```

## Динамический импорт

Этот пример показывает, как можно загрузить на страницу дополнительный модуль в зависимости от действий пользователя (в данном случае, по клику на кнопку), а затем использовать функции из загруженного модуля. Промисы - это не единственный способ использовать динамический импорт. Функция `import()` также может использоваться совместно с `await`.

```javascript
const main = document.querySelector('main');
for (const link of document.querySelectorAll('nav > a')) {
	link.addEventListener('click', (e) => {
		e.preventDefault();

		import('/modules/my-module.js')
			.then((module) => {
				module.loadPageInto(main);
			})
			.catch((err) => {
				main.textContent = err.message;
			});
	});
}
```

---

---

# Разделение кода

Бандлинг — это хорошо, но по мере роста вашего приложения, ваш бандл тоже будет расти. Особенно если вы подключаете крупные сторонние библиотеки. Вам нужно следить за кодом, который вы подключаете, чтобы случайно не сделать приложение настолько большим, что его загрузка займёт слишком много времени.

Чтобы предотвратить разрастание бандла, стоит начать «разделять» ваш бандл. Разделение кода — это возможность, поддерживаемая такими бандлерами как Webpack, Rollup или Browserify (с factor-bundle), которая может создавать несколько бандлов и загружать их по мере необходимости.

Хоть вы и не уменьшите общий объём кода вашего приложения, но избежите загрузки кода, который может никогда не понадобиться пользователю и уменьшите объём кода, необходимого для начальной загрузки.

## `import()`

Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: `import()`.

До:

```javascript
import { add } from './math';

console.log(add(16, 26));
```

После:

```javascript
import('./math').then((math) => {
	console.log(math.add(16, 26));
});
```

Когда Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения. Если вы используете Create React App, то всё уже настроено и вы можете сразу [начать использовать](https://create-react-app.dev/docs/code-splitting/) синтаксис динамического импорта. Он также поддерживается «из коробки» в [Next.js](https://nextjs.org/docs/advanced-features/dynamic-import).

Если вы настраиваете Webpack самостоятельно, то, вероятно, захотите прочитать [руководство Webpack по разделению кода](https://webpack.js.org/guides/code-splitting/). Файл конфигурации Webpack должен выглядеть [примерно так](https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269).

Если вы используете [Babel](https://babeljs.io/), вам необходимо убедиться, что он понимает синтаксис динамического импорта. Для этого вам необходимо установить пакет [@babel/plugin-syntax-dynamic-import](https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import).

---

## Ссылки

- React.lazy
  - https://ru.legacy.reactjs.org/docs/react-api.html#reactlazy
- import
  - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import
- код из урока
  - https://github.com/yankovalenko94/JS_task_answers/tree/master/React_Redux_step_23
- (EN) lazy(load)
  - https://react.dev/reference/react/lazy#lazy

# 177. React.memo, Pure Component и оптимизация скорости работы приложения

## React.memo

```javascript
const MyComponent = React.memo(function MyComponent(props) {
	/* рендер с использованием пропсов */
});
```

React.memo — это [компонент высшего порядка](https://ru.legacy.reactjs.org/docs/higher-order-components.html).

> Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов.
>
> Говоря просто, **компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент**.
>
> ```javascript
> const EnhancedComponent = higherOrderComponent(WrappedComponent);
> ```
>
> Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент.

Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов `React.memo` для повышения производительности в некоторых случаях, мемоизируя тем самым результат. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга.

`React.memo` затрагивает только изменения пропсов. Если функциональный компонент обёрнут в `React.memo` и использует [useState](https://ru.legacy.reactjs.org/docs/hooks-state.html), [useReducer](https://ru.legacy.reactjs.org/docs/hooks-reference.html#usereducer) или [useContext](https://ru.legacy.reactjs.org/docs/hooks-reference.html#usecontext), он будет повторно рендериться при изменении состояния или контекста.

По умолчанию он поверхностно сравнивает вложенные объекты в объекте `props`. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.

```javascript
function MyComponent(props) {
	/* рендер с использованием пропсов */
}
function areEqual(prevProps, nextProps) {
	/*
  возвращает true, если nextProps рендерит
  тот же результат что и prevProps,
  иначе возвращает false
  */
}
export default React.memo(MyComponent, areEqual);
```

Этот метод предназначен только для [**оптимизации производительности**](https://ru.legacy.reactjs.org/docs/optimizing-performance.html). Не полагайтесь на него, чтобы «предотвратить» рендер, так как это может привести к ошибкам.

> Примечание
>
> В отличие от метода [shouldComponentUpdate()](https://ru.legacy.reactjs.org/docs/react-component.html#shouldcomponentupdate) для классовых компонентов, функция `areEqual` возвращает `true`, если пропсы равны, и значение `false`, если пропсы не равны. Это обратные значения для `shouldComponentUpdate`.

---

## `shouldComponentUpdate()`

```javascript
shouldComponentUpdate(nextProps, nextState);
```

Используйте `shouldComponentUpdate()`, чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов. По умолчанию происходит повторный рендер при любом изменении состояния. В большинстве случаев вы должны полагаться на это поведение.

`shouldComponentUpdate()` вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно `true`. Этот метод не вызывается при первом рендере или когда используется `forceUpdate()`.

Этот метод нужен только для [**повышения производительности**](https://ru.legacy.reactjs.org/docs/optimizing-performance.html). Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого **используйте [PureComponent](https://ru.legacy.reactjs.org/docs/react-api.html#reactpurecomponent)**, который позволяет не описывать поведение `shouldComponentUpdate()` вручную. `PureComponent` поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

Если вы уверены, что хотите написать его вручную, вы можете сравнить `this.props` с `nextProps`, а `this.state` с `nextState`. Верните `false` чтобы пропустить обновление React. Возврат `false` не предотвращает повторный рендер дочерних компонентов при изменении **_их_** состояния.

Мы не рекомендуем делать глубокое сравнение или использовать `JSON.stringify()` в `shouldComponentUpdate()`. Это неэффективно и плохо влияет на производительность.

В настоящее время, если `shouldComponentUpdate()` возвращает `false`, то `UNSAFE_componentWillUpdate()`, `render()` и `componentDidUpdate()` не будут вызваны. В будущем React может рассматривать `shouldComponentUpdate()` как подсказку, а не строгое указание. В таком случае возврат `false` сможет привести к повторному рендеру компонента.

---

## `React.PureComponent`

> Если требуется меморизировать классовый компонент, то его необходимо наследовать от `React.PureComponent` а не от `React.Component`.

`React.PureComponent` похож на `React.Component`. Отличие заключается в том, что `React.Component` не реализует `shouldComponentUpdate()`, а `React.PureComponent` реализует его поверхностным сравнением пропсов и состояния.

Если метод `render()` вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать `React.PureComponent`.

> Примечание
>
> Метод `shouldComponentUpdate()` базового класса `React.PureComponent` делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс `PureComponent` только тогда, когда вы ожидаете использовать простые пропсы и состояние, или используйте [forceUpdate()](https://ru.legacy.reactjs.org/docs/react-component.html#forceupdate), когда знаете, что вложенные структуры данных изменились. Также подумайте об использовании [иммутабельных объектов](https://immutable-js.com/), чтобы упростить процесс сравнения вложенных данных.
>
> Кроме того, метод `shouldComponentUpdate()` базового класса `React.PureComponent` пропускает обновление пропсов для всего поддерева компонентов. Убедитесь, что все дочерние компоненты также являются «чистыми».

> **перерендерится, если метод `shouldComponentUpdate` вернёт `true`, в отличии от функфиональных компонентов**

```javascript
// можно наследовать и от `React.Component`
// но тогда `shouldComponentUpdate` необходимо реализовать самостоятельно
// class Form extends React.Component {
class Form extends React.PureComponent {
	// встроенный `shouldComponentUpdate` реализует поверхностное сравнение
	// более сложное сравнение приходится реализовывать самостоятельно
	shouldComponentUpdate(_props) {
		const vRes =
			this.props.mail.name !== _props.mail.name ||
			this.props.text !== _props.text;
		console.log('Form.shouldComponentUpdate', _props, 'vRes=', vRes);
		return vRes;
	}

	render() {
		console.log('>> Form.render');

		return (
			<Container>
				{
					// здесь контент для рендера
				}
			</Container>
		);
	}
}
```

---

## Ссылки

- React.memo
  - https://ru.legacy.reactjs.org/docs/react-api.html#reactmemo
- Use React.memo() wisely
  - https://dmitripavlutin.com/use-react-memo-wisely/
- shouldComponentUpdate()
  - https://ru.legacy.reactjs.org/docs/react-component.html#shouldcomponentupdate
- Оптимизация производительности
  - https://ru.legacy.reactjs.org/docs/optimizing-performance.html
- App.js
  - https://drive.google.com/file/d/1z20v4ZF6WTAIaUwABmg7WFaBe9vLdipU/view
- memo
  - https://react.dev/reference/react/memo

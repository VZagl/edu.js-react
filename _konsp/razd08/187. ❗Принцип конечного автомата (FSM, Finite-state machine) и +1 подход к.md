# 187. ❗Принцип конечного автомата (FSM, Finite-state machine) и +1 подход к

> конечный автомат (finite-state machine, FSM) — это математическая абстракция, модель, которая может находиться только в одном из конечного числа состояний в каждый конкретный момент времени. Автомат умеет переходить из одного состояния в другое в ответ на данные, которые подаются на вход; изменение состояния называется переходом. FSM определяется списком его состояний, начальным состоянием и инпутами, запускающими переходы.

---

## [Создание машины состояний средствами JavaScript](https://habr.com/ru/companies/ruvds/articles/346908/)

```javascript
const machine = {
  'idle': {
    click: function () { ... }
  },
  'fetching': {
    success: function () { ... },
    failure: function () { ... }
  },
  'error': {
    'retry': function () { ... }
  }
}
```

Состояния представлены объектами, возможные входные сигналы состояний — методами объектов. Однако исходного состояния тут нет. Изменим вышеприведённый код, приведя его к следующему виду:

```javascript
const machine = {
  state: 'idle',
  transitions: {
    'idle': {
      click: function() { ... }
    },
    'fetching': {
      success: function() { ... },
      failure: function() { ... }
    },
    'error': {
      'retry': function() { ... }
    }
  }
}
```

После того, как мы определили все состояния, имеющие смысл, мы готовы отправлять им входные сигналы и менять состояние системы. Делать это будем, используя два следующих вспомогательных метода:

```javascript
const machine = {
  dispatch(actionName, ...payload) {
    const actions = this.transitions[this.state];
    const action = this.transitions[this.state][actionName];

    if (action) {
      action.apply(machine, ...payload);
    }
  },
  changeStateTo(newState) {
    this.state = newState;
  },
  ...
}
```

Функция `dispatch` проверяет, имеется ли действие с заданным именем среди переходов текущего состояния. Если это так, она вызывает это действие, передавая ему переданные ей при вызове данные. Кроме того, обработчик `action` вызывается с `machine` в качестве контекста, поэтому мы можем диспетчеризировать другое действие с помощью `this.dispatch(<action>)` или изменить состояние с помощью `this.changeStateTo(<new state>)`.

Следуя пути пользователя из нашего примера, первое действие, которое нам надо диспетчеризировать — это `click`. Вот как выглядит обработчик этого действия:

```javascript
transitions: {
  'idle': {
    click: function () {
      this.changeStateTo('fetching');
      service.getData().then(
        data => {
          try {
            this.dispatch('success', JSON.parse(data));
          } catch (error) {
            this.dispatch('failure', error)
          }
        },
        error => this.dispatch('failure', error)
      );
    }
  },
  ...
}

machine.dispatch('click');
```

Сначала мы изменяем состояние машины на `fetching`. Затем выполним запрос к серверу. Предположим, что у нас имеется служба с методом `getData`, который возвращает промис. После того, как этот промис будет разрешён и данные будут успешно разобраны, мы диспетчеризируем событие `succes`, иначе — `failure`.

Пока всё идёт как надо. Далее нам нужно реализовать действия `success` и `failure` и описать входные данные состояния `fetching`:

```javascript
transitions: {
  'idle': { ... },
  'fetching': {
    success: function (data) {
      // вывод данных
      this.changeStateTo('idle');
    },
    failure: function (error) {
      this.changeStateTo('error');
    }
  },
  ...
}
```

Обратите внимание на то, как мы избавили себя от необходимости думать о предыдущем процессе. Мы не заботимся о щелчках пользователя по кнопке, или о том, что происходит с HTTP-запросом. Мы знаем, что приложение находится в состоянии `fetching`, и мы ожидаем появления лишь этих двух действий. Это немного похоже на создание новых механизмов приложения, которые работают в изоляции.

Последнее, с чем нам осталось разобраться — это состояние `error`. Будет очень хорошо, если мы создадим тут код для реализации повторной попытки, в результате приложение сможет восстановиться после возникновения ошибки.

```javascript
transitions: {
  'error': {
    retry: function () {
      this.changeStateTo('idle');
      this.dispatch('click');
    }
  }
}
```

Здесь придётся копировать тот код, который уже написан в обработчике `click`. Для того чтобы этого избежать, нам либо нужно объявить обработчик как функцию, доступную обоим действиям, либо сначала перейти в состояние `idle`, а затем диспетчеризировать действие `click` самостоятельно.

---

## Ссылки

- Машины состояний и разработка веб-приложений
  - https://habr.com/ru/companies/ruvds/articles/346908/
- Улучшаем ваш React с помощью конечных автоматов
  - https://medium.com/devschacht/jean-paul-delimat-boost-your-react-with-state-machines-8a22885dc348
- Конечный автомат: теория и реализация
  - https://tproger.ru/translations/finite-state-machines-theory-and-implementation/
- Как в React избавиться от сложности в управлении состоянием — отчёт по итогам поездки на React Amsterdam
  - https://habr.com/ru/companies/nix/articles/354106/
- xstate
  - https://xstate.js.org/docs/recipes/react.html
- Robot
  - https://thisrobot.life
- machina-js
  - machina-js.org
- Код из урока + дз
  - https://github.com/yankovalenko94/JS_task_answers/tree/master/React_Redux_step_27

# 194. Соединяем React и Redux при помощи connect

## `connect()`

Функция `connect()` подключает компонент React к Redux `store`.

Он предоставляет подключенному компоненту части данных, которые ему нужны из `store`, и функции, которые он может использовать для отправки действий в `store`.

Он не изменяет переданный ему класс компонента; вместо этого он возвращает новый связанный класс компонента, который является оболочкой для компонента, который вы передали.

```javascript
function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)
```

`mapStateToProps` и `mapDispatchToProps` имеют дело с `state` и `dispatch` вашего Redux `store` соответственно. `state` и `dispatch` будут переданы вашим функциям `mapStateToProps` или `mapDispatchToProps` в качестве первого аргумента.

Возвраты `mapStateToProps` и `mapDispatchToProps` внутри называются `stateProps` и `dispatchProps` соответственно. Они будут переданы в `mergeProps`, если определены, в качестве первого и второго аргумента, где третьим аргументом будет `ownProps`. Объединенный результат, обычно называемый `mergedProps`, затем будет предоставлен подключенному компоненту.

## connect() Parameters

`connect` принимает четыре разных параметра, все необязательные. По соглашению они называются:

1. `mapStateToProps?: Function`
2. `mapDispatchToProps?: Function | Object`
3. `mergeProps?: Function`
4. `options?: Object`

## `mapStateToProps?: (state, ownProps?) => Object`

Если указана функция `mapStateToProps`, новый компонент-оболочка подпишется на обновления Redux `store`. Это означает, что при каждом обновлении `store` будет вызываться `mapStateToProps`. Результатом `mapStateToProps` должен быть простой объект, который будет объединен с пропсами обернутого компонента. Если вы не хотите подписываться на обновления `store`, передайте `null` или `undefined` вместо `mapStateToProps`.

### Parameters

- `state: Object`
- `ownProps?: Object`

Функция `mapStateToProps` принимает максимум два параметра. Количество объявленных параметров функции влияет на то, когда она будет вызвана. Это также определяет, получит ли функция `ownProps`. [См. примечания здесь](https://react-redux.js.org/api/connect#the-arity-of-maptoprops-functions).

`state`

Если ваша функция `mapStateToProps` объявлена **как принимающая один параметр**, она будет вызываться всякий раз, когда изменяется состояние `store`, и состояние `store` будет задано в качестве единственного параметра.

```javascript
const mapStateToProps = (state) => ({ todos: state.todos });
```

`ownProps`

Если ваша функция `mapStateToProps` объявлена **​​как принимающая два параметра**, она будет вызываться всякий раз, когда изменяется состояние `store` или когда компонент-оболочка получает новые реквизиты (на основе поверхностного сравнения). В качестве первого параметра ему будет передано состояние `store`, а в качестве второго параметра — свойства компонента-оболочки.

Второй параметр обычно называется `ownProps` по соглашению.

```javascript
const mapStateToProps = (state, ownProps) => ({
	todo: state.todos[ownProps.id],
});
```

### Returns

Ожидается, что ваши функции `mapStateToProps` будут возвращать объект. Этот объект, обычно называемый `stateProps`, будет объединен как свойства с вашим подключенным компонентом. Если вы определите `mergeProps`, он будет указан в качестве первого параметра для `mergeProps`.

Возврат `mapStateToProps` определяет, будет ли повторно отображаться подключенный компонент ([подробности здесь](https://react-redux.js.org/using-react-redux/connect-mapstate#return-values-determine-if-your-component-re-renders)).

Дополнительные сведения о рекомендуемом использовании `mapStateToProps` см. в нашем [руководстве по использованию mapStateToProps](https://react-redux.js.org/using-react-redux/connect-mapstate).

> Вы можете определить `mapStateToProps` и `mapDispatchToProps` как фабричные функции, т. е. вы возвращаете функцию вместо объекта. В этом случае ваша возвращаемая функция будет рассматриваться как настоящая `mapStateToProps` или `mapDispatchToProps` и вызываться при последующих вызовах. Вы можете увидеть [заметки о фабричных функциях](https://react-redux.js.org/api/connect#factory-functions) или наше руководство по оптимизации производительности.

## `mapDispatchToProps?: Object | (dispatch, ownProps?) => Object`

Этот второй параметр функции `connect()`, обычно называемый `mapDispatchToProps`, может быть либо объектом, либо функцией, либо не предоставляться.

Ваш компонент получит отправку по умолчанию, т. е. если вы не укажете второй параметр для `connect()`:

```javascript
// do not pass `mapDispatchToProps`
connect()(MyComponent);
connect(mapState)(MyComponent);
connect(mapState, null, mergeProps, options)(MyComponent);
```

Если вы определяете `mapDispatchToProps` как функцию, она будет вызываться с максимум двумя параметрами.

### Parameters

- `dispatch: Function`
- `ownProps?: Object`

### `dispatch`

Если ваш `mapDispatchToProps` объявлен как функция с одним параметром, ей будет передан `dispatch` вашего `store`.

```javascript
const mapDispatchToProps = (dispatch) => {
	return {
		// dispatching plain actions
		increment: () => dispatch({ type: 'INCREMENT' }),
		decrement: () => dispatch({ type: 'DECREMENT' }),
		reset: () => dispatch({ type: 'RESET' }),
	};
};
```

### `ownProps`

Если ваша функция `mapDispatchToProps` объявлена ​​как принимающая два параметра, она будет вызываться с отправкой в ​​качестве первого параметра и реквизитами, переданными компоненту-оболочке в качестве второго параметра, и будет повторно вызываться всякий раз, когда подключенный компонент получает новые реквизиты.

Второй параметр обычно называется `ownProps` по соглашению.

```javascript
// binds on component re-rendering
<button onClick={() => this.props.toggleTodo(this.props.todoId)} />;

// binds on `props` change
const mapDispatchToProps = (dispatch, ownProps) => ({
	toggleTodo: () => dispatch(toggleTodo(ownProps.todoId)),
});
```

Количество объявленных параметров функции `mapDispatchToProps` определяет, получают ли они `ownProps`. [См. примечания здесь](https://react-redux.js.org/api/connect#the-arity-of-maptoprops-functions).

### Returns

Ожидается, что ваши функции `mapDispatchToProps` будут возвращать объект. Каждое поле объекта должно быть функцией, вызов которой должен отправить действие в `store`.

Возврат ваших функций `mapDispatchToProps` рассматривается как `dispatchProps`. Он будет объединен в качестве реквизита с вашим подключенным компонентом. Если вы определите `mergeProps`, он будет предоставлен в качестве второго параметра для `mergeProps`.

```javascript
const createMyAction = () => ({ type: 'MY_ACTION' });
const mapDispatchToProps = (dispatch, ownProps) => {
	const boundActions = bindActionCreators({ createMyAction }, dispatch);
	return {
		dispatchPlainObject: () => dispatch({ type: 'MY_ACTION' }),
		dispatchActionCreatedByActionCreator: () => dispatch(createMyAction()),
		...boundActions,
		// you may return dispatch here
		dispatch,
	};
};
```

Дополнительные сведения о рекомендуемом использовании [см. в нашем руководстве](https://react-redux.js.org/using-react-redux/connect-mapdispatch) по использованию `mapDispatchToProps`.

> Вы можете определить `mapStateToProps` и `mapDispatchToProps` как фабричные функции, т. е. вы возвращаете функцию вместо объекта. В этом случае ваша возвращаемая функция будет рассматриваться как настоящая `mapStateToProps` или `mapDispatchToProps` и вызываться при последующих вызовах.

## Object Shorthand Form

mapDispatchToProps может быть объектом, где каждое поле является [action creator](https://redux.js.org/glossary#action-creator).

```javascript
import { addTodo, deleteTodo, toggleTodo } from './actionCreators';

const mapDispatchToProps = {
	addTodo,
	deleteTodo,
	toggleTodo,
};

export default connect(null, mapDispatchToProps)(TodoApp);
```

В этом случае React-Redux привязывает `dispatch` вашего `store` к каждому из создателей действий с помощью bindActionCreators. Результат будет рассматриваться как dispatchProps, который будет либо напрямую объединен с вашими подключенными компонентами, либо передан в mergeProps в качестве второго аргумента.

```javascript
// внутри React-Redux вызывает `bindActionCreators`
// для привязки action creator к `dispatch` вашего `store`
bindActionCreators(mapDispatchToProps, dispatch);
```

У нас также есть раздел в нашем руководстве `mapDispatchToProps` по использованию сокращенной формы объекта [здесь](https://react-redux.js.org/using-react-redux/connect-mapdispatch#defining-mapdispatchtoprops-as-an-object).

## `mergeProps?: (stateProps, dispatchProps, ownProps) => Object`

Если указано, определяет, как определяются окончательные реквизиты для вашего собственного обернутого компонента. Если вы не предоставляете `mergeProps`, ваш обернутый компонент по умолчанию получает `{...ownProps, ...stateProps, ...dispatchProps}`.

### Parameters

`mergeProps` должен быть указан максимум с тремя параметрами. Они являются результатом функций `mapStateToProps()`, `mapDispatchToProps()` и `props` компонента-оболочки соответственно:

1. `stateProps`
2. `dispatchProps`
3. `ownProps`

Поля в обычном объекте, который вы из него возвращаете, будут использоваться в качестве реквизита для обернутого компонента. Вы можете указать эту функцию для выбора части состояния на основе реквизита или для привязки `action creator` к определенной переменной из `props`.

### Returns

Возвращаемое значение `mergeProps` называется `mergedProps`, и поля будут использоваться в качестве `props` для обернутого компонента.

> Примечание.
>
> Создание новых значений в `mergeProps` приведет к повторному рендерингу. Рекомендуется _меморизировать_ поля, чтобы избежать ненужных повторных рендеров.

### `options?: Object`

```javascript
{
  context?: Object,
  areStatesEqual?: Function,
  areOwnPropsEqual?: Function,
  areStatePropsEqual?: Function,
  areMergedPropsEqual?: Function,
  forwardRef?: boolean,
}
```

### `context: Object`

React-Redux v6 позволяет вам предоставить собственный экземпляр контекста, который будет использоваться React-Redux. Вам необходимо передать экземпляр вашего контекста как `<Provider/>`, так и вашему подключенному компоненту. Вы можете передать контекст подключенному компоненту, либо передав его здесь как поле параметра, либо в качестве `props` подключенного компонента при рендеринге.

```javascript
// const MyContext = React.createContext();
connect(mapStateToProps, mapDispatchToProps, null, { context: MyContext })(
	MyComponent
);
```

#### `areStatesEqual: (next: Object, prev: Object, nextOwnProps: Object, prevOwnProps: Object) => boolean`

- default value: `strictEqual: (next, prev) => prev === next`

Сравнивает входящее `state` `store` с его предыдущим значением.

```javascript
const areStatesEqual = (next, prev) =>
	prev.entities.todos === next.entities.todos;
```

Вы можете захотеть переопределить `areStatesEqual`, если ваша функция `mapStateToProps` требует больших вычислительных ресурсов, а также касается только небольшого фрагмента вашего `state`. Приведенный выше пример эффективно игнорирует изменения `state` для всего, кроме этого фрагмента `state`. Кроме того, `areStatesEqual` предоставляет `nextOwnProps` и `prevOwnProps`, чтобы при необходимости обеспечить более эффективное определение вашего `state`, в котором заинтересован ваш подключенный компонент.

Это, вероятно, повлияет и на другие проверки равенства, в зависимости от вашей функции `mapStateToProps`.

#### `areOwnPropsEqual: (next: Object, prev: Object) => boolean`

- default value: `shallowEqual: (objA, objB) => boolean` ( returns `true` when each field of the objects is equal )

Сравнивает входящие `props` с их предыдущим значением.

Вы можете переопределить `areOwnPropsEqual` как способ внесения в белый список входящих `props`. Вам также нужно будет реализовать `mapStateToProps`, `mapDispatchToProps` и `mergeProps`, чтобы добавить `props` в белый список. (Может быть проще добиться этого другими способами, например, используя [mapProps recompose](https://github.com/acdlite/recompose/blob/master/docs/API.md#mapprops).)

#### `areStatePropsEqual: (next: Object, prev: Object) => boolean`

- type: `function`
- default value: `shallowEqual`

Сравнивает результат `mapStateToProps` с его предыдущим значением.

#### `areMergedPropsEqual: (next: Object, prev: Object) => boolean`

- default value: `shallowEqual`

Сравнивает результат `mergeProps` с его предыдущим значением.

Вы можете переопределить `areStatePropsEqual`, чтобы использовать `strictEqual`, если ваш `mapStateToProps` использует мемоизированный селектор, который будет возвращать новый объект только в том случае, если соответствующий реквизит изменился. Это будет очень небольшим улучшением производительности, поскольку позволит избежать дополнительных проверок на равенство для отдельных свойств каждый раз, когда вызывается `mapStateToProps`.

Вы можете переопределить `areMergePropsEqual` для реализации `deepEqual`, если ваши селекторы создают сложные `props`. пример: вложенные объекты, новые массивы и т. д. (Глубокая проверка на равенство может быть быстрее, чем просто повторный рендеринг.)

#### `forwardRef: boolean`

Если для подключения было передано `{forwardRef : true}`, добавление ссылки к подключенному компоненту-оболочке фактически вернет экземпляр обернутого компонента.

## `connect()` Returns

Возврат `connect()` — это функция-оболочка, которая берет ваш компонент и возвращает компонент-оболочку с добавленными им дополнительными параметрами.

```javascript
import { login, logout } from './actionCreators';

const mapState = (state) => state.user;
const mapDispatch = { login, logout };

// первый вызов: возвращает hoc, который можно использовать для переноса любого компонента
const connectUser = connect(mapState, mapDispatch);

// второй вызов: возвращает компонент-оболочку с mergedProps
// вы можете использовать hoc, чтобы позволить различным компонентам получить одинаковое поведение
const ConnectedUserLogin = connectUser(Login);
const ConnectedUserProfile = connectUser(Profile);
```

В большинстве случаев функция-обертка будет вызвана сразу, без сохранения во временной переменной:

```javascript
import { login, logout } from './actionCreators';

const mapState = (state) => state.user;
const mapDispatch = { login, logout };

// вызываем connect для генерации функции-оболочки и сразу же вызываем
// функцию-оболочку для создания окончательного компонента-оболочки
export default connect(mapState, mapDispatch)(Login);
```

## [Example Usage](https://react-redux.js.org/api/connect#example-usage)

---

===================================================

---

`index.js`:

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { createStore } from 'redux';
import { Provider } from 'react-redux';

import reducer from './reducer';
import App from './components/App';

// создаём Store
const store = createStore(reducer);

ReactDOM.createRoot(document.getElementById('root')).render(
	// `Provider` позволит получить доступ к `store` из любого уровня вложенности компонентов
	<Provider store={store}>
		<App />
	</Provider>
);
```

`App.js`:

```javascript
import React from 'react';

import Counter from './Counter';

const App = () => {
	return <Counter />;
};

export default App;
```

`Counter.js`:

_это функциональный компонент_

```javascript
/* это функциональный компонент */

import React from 'react';
import { connect } from 'react-redux';
//import { bindActionCreators } from 'redux';
import * as actions from '../actions';

const Counter = ({ counter, inc, dec, rnd }) => {
	return (
		<div className='jumbotron'>
			<h1>{counter}</h1>
			<button className='btn btn-primary' onClick={dec}>
				DEC
			</button>
			<button className='btn btn-primary' onClick={inc}>
				INC
			</button>
			<button className='btn btn-primary' onClick={rnd}>
				RND
			</button>
		</div>
	);
};

// функция "mapStateToProps" должна быть "чистой"
const mapStateToProps = (state) => {
	return { counter: state.value };
};

/* вариант 1
const mapDispatchToProps = (dispatch) => {
	return {
		inc: () => dispatch({ type: 'INC' }),
		dec: () => dispatch({ type: 'DEC' }),
		rnd: () => dispatch({ type: 'RND' }),
	};
};
*/

/* вариант 2
const mapDispatchToProps = (dispatch) => {
	const { inc, dec, rnd } = actions;
	return {
		inc: () => dispatch(inc()),
		dec: () => dispatch(dec()),
		rnd: () => dispatch(rnd()),
	};
};
*/

/* вариант 3
const mapDispatchToProps = (dispatch) => {
	const { inc, dec, rnd } = bindActionCreators(actions, dispatch);
	return { inc, dec, rnd };
};
*/

/* вариант 4
const mapDispatchToProps = (dispatch) => bindActionCreators(actions, dispatch);

export default connect(mapStateToProps, mapDispatchToProps)(Counter);
*/

// вариант 5
// `connect` из `actions` самостоятельно создаст нужную структуру
export default connect(mapStateToProps, actions)(Counter);
```

`Counter.js`:

_это классовый компонент_

```javascript
/* это классовый компонент */

import React from 'react';
import { connect } from 'react-redux';
import * as actions from '../actions';

class Counter extends React.Component {
	render() {
		const { counter, inc, dec, rnd } = this.props;

		return (
			<div className='jumbotron'>
				<h1>{counter}</h1>
				<button className='btn btn-primary' onClick={dec}>
					DEC
				</button>
				<button className='btn btn-primary' onClick={inc}>
					INC
				</button>
				<button className='btn btn-primary' onClick={rnd}>
					RND
				</button>
			</div>
		);
	}
}

// функция "mapStateToProps" должна быть "чистой"
const mapStateToProps = (state) => {
	return { counter: state.value };
};

export default connect(mapStateToProps, actions)(Counter);
```

`actions.js`:

```javascript
// action creator
export const inc = () => ({ type: 'INC' });
export const dec = () => ({ type: 'DEC' });
export const rnd = () => ({
	type: 'RND',
	payload: Math.floor(Math.random() * 100 - 50),
});
```

`reducer.js`:

```javascript
const initialState = { value: 0 };

const reducer = (state = initialState, action) => {
	// негласное правило: `action.type` писать `БОЛЬШИМИ БУКВАМИ`
	switch (action.type) {
		case 'INC':
			return { ...state, value: state.value + 1 };
		case 'DEC':
			return { ...state, value: state.value - 1 };
		case 'RND':
			/* так делать нельзя так как изменяется логика работы редюсера
			return Math.floor(Math.random() * 20 - 10);
			*/
			return { ...state, value: state.value + action.payload };

		default:
			return state;
	}
};

export default reducer;
```

---

## Ссылки

- useSelector vs connect (react-redux)
  - https://www.samdawson.dev/article/react-redux-use-selector-vs-connect
- connect()
  - https://react-redux.js.org/api/connect
- Counter.js
  - https://drive.google.com/file/d/1ikBQl9704WzaMR3Ki-5VfeWEfn0BMqXM/view

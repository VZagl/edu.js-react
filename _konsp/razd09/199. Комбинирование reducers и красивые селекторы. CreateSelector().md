# 199. Комбинирование reducers и красивые селекторы. CreateSelector()

---

# `combineReducers(reducers)`

Как только ваше приложение становится все более сложным, вы захотите разделить ваш [функцию редюсер](https://rajdee.gitbooks.io/redux-in-russian/content/docs/Glossary.html#reducer) на отдельные функции, которые управляют независимыми частями [состояния](https://rajdee.gitbooks.io/redux-in-russian/content/docs/Glossary.html#state).

Вспомогательная функция `combineReducers` преобразует объект, значениями которого являются различные функции редюсеры, в одну функцию редюсер, которую можно передать в метод [createStore](https://rajdee.gitbooks.io/redux-in-russian/content/docs/api/createStore.html).

Результирующий редюсер вызывает вложенные редюсеры и собирает их результаты в единый объект состояния. **Состояние, созданное именами `combineReducers()`, сохраняет состояние каждого редуктора под их ключами, переданные в `combineReducers()`**

Пример:

```javascript
rootReducer = combineReducers({potato: potatoReducer, tomato: tomatoReducer})
// Это создаст следующий объект состояния
{
  potato: {
    // ... potatoes и другое состояние управляемое potatoReducer ...
  },
  tomato: {
    // ... tomatoes и другое состояние управляемое tomatoReducer, возможно, какой-нибудь хороший соус? ...
  }
}
```

Вы можете управлять именами ключей состояний, используя разные ключи для редюсеров в переданном объекте. Например, вы можете называть `combineReducers({ todos: myTodosReducer, counter: myCounterReducer })` для формы состояния как `{todos, counter}`.

Популярное соглашение - назвать редюсеры после разделения состояний, которыми они управляют, поэтому вы можете использовать сокращенную обозначение свойства ES6: `combReducers ({counter, todos})`. Это эквивалентно написанию `combReducers ({counter: counter, todos: todos})`.

## Параметры

`reducers` (Object): объект, значения которого соответствуют различным функциям редюсерам, которые должны быть объединены в один. Ниже идут примечания для некоторых правил, которым должен следовать каждый переданный редюсер.

> Ранее документация предлагала использовать ES6-синтаксис `import * as reducers` для получения объекта редюсеров. Это было источником многочисленной путаницы, поэтому сейчас рекомендуется экспортировать один редюсер, полученный с помощью `combineReducers()` из `reducers/index.js` вместо этого. Ниже приведен пример.

## Возвращает

`( Function )`: редюсер, который вызывает каждый редюсер внутри объекта `reducers` и создает объект состояния с той же формой.

## Примечания

Эта функция слегка самоуверенная и искажена, чтобы помочь новичкам избежать общих ошибок. Именно поэтому она пытается применять некоторые правила, которым не нужно следовать, если вы пишете корневой редюсер вручную.

Любой редюсер передаваемый `combineReducers` должен соответствовать этим правилам:

- Для любых экшенов, которые не определены, он должен возвращать `state`, переданный ему в качестве первого аргумента.

- Он никогда не должен возвращать `undefined`. Это очень легко сделать по ошибке через предыдущие `return`, поэтому `combineReducers` создает исключение, если вы сделали это, предотвращая появление ошибки где-нибудь еще.

- Если `state` переданный ему не определен (`undefined`), то он должен возвратить начальное состояние (`state`) для этого конкретного редюсера. Согласно предыдущему правилу, начальное состояние (`state`) не должно быть равно `undefined`. Это удобно указывать с ES6-синтаксисом опциональных аргументов, но вы можете также явно проверить первый аргумент на `undefined`.

В то время как `combineReducers` пытается проверить, что ваши редюсеры соответствуют некоторым из этих правил, вам следует помнить о них и сделать все возможное, чтобы следовать им. `combineReducers` проверит ваши редюсеры, передав имu `ndefined`; это делается, даже если вы указываете начальное состояние на `Redux.createStore(combineReducers(...), initialState)`. Поэтому вы должны гарантировать, что ваши редюсеры будут работать должным образом при получении `undefined` в качестве `state`, даже если вы никогда не намереваетесь фактически получить `undefined` в своем собственном коде.

## Example:

**reducers/todos.js**

```javascript
export default function todos(state = [], action) {
	switch (action.type) {
		case 'ADD_TODO':
			return state.concat([action.text]);
		default:
			return state;
	}
}
```

**reducers/counter.js**

```javascript
export default function counter(state = 0, action) {
	switch (action.type) {
		case 'INCREMENT':
			return state + 1;
		case 'DECREMENT':
			return state - 1;
		default:
			return state;
	}
}
```

**reducers/index.js**

```javascript
import { combineReducers } from 'redux';
import todos from './todos';
import counter from './counter';

export default combineReducers({
	todos,
	counter,
});
```

**App.js**

```javascript
import { createStore } from 'redux';
import reducer from './reducers/index';

const store = createStore(reducer);
console.log(store.getState());
// {
//   counter: 0,
//   todos: []
// }

store.dispatch({
	type: 'ADD_TODO',
	text: 'Use Redux',
});
console.log(store.getState());
// {
//   counter: 0,
//   todos: [ 'Use Redux' ]
// }
```

## Советы

- Этот помощник – это всего лишь удобство! Вы можете написать свой собственный `combineReducers` который [работает иначе](https://github.com/acdlite/reduce-reducers) или даже вручную собрать объект состояния из вложенного редюсера и написать родительскую функцию-редюсер явно, как можно было бы написать любую другую функцию.

- Вы можете вызвать `combineReducers` на любом уровне иерархии редюсера. Это не обязательно должно произойти наверху. На самом деле, вы можете использовать его снова, чтобы разделить "детские" редюсеры, которые получаются слишком сложными, на независимых "внуков" и так далее.

---

# Селекторы и библотека `reselect`

**Селекторы** – это функции, которые принимают state и достают (возвращают) из него данные, при этом могут при необходимости их обрабатывать дополнительно даже какой-то очень сложной логикой (фильтры, расчеты и т.д.). Эти функции-селекторы вызываются внутри mapStateToProps вместо обычного прямого доставания со стейта.

**Reselect** – это библиотека, благодаря которой селекторам не приходится постоянно перезапускать рендеринг без изменений в стейте. При первом вызове реселекта значения зависимостей (простых передаваемых внутрь селекторов) кешируются, а при следующих вызовах данные этих зависимостей сравниваются с кешироваными. Если данные простых селекторов не изменились, то сразу возвращается кеншированный результат и без лишней перерисовки компоненты, если же что-то из зависимостей изменилось в стейте по сравнению с кешем то тогда уже вызывается селектор с “дорогими” вычислениями.

## Использование секлекторов

1. Допустим у нас в `mapStateToProps` файла `UsersContainer.jsx` были следующие значения:

   ```javascript
   let mapStateToProps = (state) => {
   	return {
   		users: state.profilePage.users,
   		pageSize: state.profilePage.pageSize,
   		totalUsersCount: state.profilePage.totalUsersCount,
   		currentPage: state.profilePage.currentPage,
   		isFetching: state.profilePage.isFetching(state),
   		followingInProgress: state.profilePage.followingInProgress,
   	};
   };
   ```

2. Чтобы применить селекторы мы создаем файл src/redux/users-selectors.js, в котором и прописываем селекторы для каждого из этих значений:

   ```javascript
   export const getUsers = (state) => {
   	return state.usersPage.users;
   };

   export const getPageSize = (state) => {
   	return state.usersPage.pageSize;
   };

   export const getTotalUsersCount = (state) => {
   	return state.usersPage.totalUsersCount;
   };

   export const getCurrentPage = (state) => {
   	return state.usersPage.currentPage;
   };

   export const getIsFetching = (state) => {
   	return state.usersPage.isFetching;
   };

   export const getFollowingInProgress = (state) => {
   	return state.usersPage.followingInProgress;
   };
   ```

   Как видим, селекторы принято называть начиная с “get”. Все они экспортируются.

3. Теперь все эти функции импортируем в наш файл UsersContainer.jsx и вызываем вместо прямого обращения к стейту внутриmapStateToProps:

   ```javascript
   import {
   	getPageSize,
   	getUsers,
   	getTotalUsersCount,
   	getCurrentPage,
   	getIsFetching,
   	getFollowingInProgress,
   } from '../../redux/users-selectors';

   // ...

   let mapStateToProps = (state) => {
   	return {
   		users: getUsers(state),
   		pageSize: getPageSize(state),
   		totalUsersCount: getTotalUsersCount(state),
   		currentPage: getCurrentPage(state),
   		isFetching: getIsFetching(state),
   		followingInProgress: getFollowingInProgress(state),
   	};
   };

   // ...
   ```

## Использование библиотеки `reselect`

1.  Устанавливаем ее:

    ```bash
    npm install reselect
    ```

    либо

    ```bash
    yarn add reselect
    ```

2.  Внутри нашего файла `users-selectors.js` с селекторами импортируем `createSelector`:

    ```javascript
    import { createSelector } from 'reselect';
    ```

3.  Теперь в качестве примера применим `reselect` для `getUsers`. Для этого сам наш старый простой селектор `getUsers`, который только получал данные, переименовываем в `getUsersSelector`, а затем создадим новый `getUsers`, который уже будет не просто селектор, а `createSelector`. При этом первым параметром он примет наш простой селектор `getUsersSelector` (называется зависимостью), а вторым – название переменной, которая будет содержать возвращаемое значение нашим простым селектором:

    ```javascript
    import { createSelector } from 'reselect';

    const getUsersSelector = (state) => {
    	return state.usersPage.users;
    };

    export const getUsers = createSelector(getUsersSelector, (users) => {
    	return users;
    });
    ```

    На самом деле это очень простой пример. На практике, например, одни селектор может вызываться еще одним промежуточным селектором, который делает какие-либо вычесления, а тот уже потом будет передан в криэйт-селектор:

    ```javascript
    const getUsers = (state) => {
    	return state.usersPage.users;
    };

    const getUsersSelector = (state) => {
    	return getUsers(state).filter((u) => true);
    };

    export const getUsersSuperSelector = createSelector(
    	getUsersSelector,
    	(users) => {
    		return users.filter((u) => true);
    	}
    );
    ```

    Либо же мы можем подписаться сразу на несколько селекторов (создать больше зависимостей) и производить более серьезные расчеты внутри, как селектора, так и криэйт-селектора:

    ```javascript
    export const getUsers = createSelector(
    	getUsersSelector,
    	getIsFetching,
    	(users) => {
    		return users.filter((u) => true);
    	}
    );
    ```

## Зачем нужны селекторы?

На первый взгляд может показаться, что они усложняют работу. Но благодаря им при каких-либо изменениях в названии переменных внутри стейта нам не нужно будет менять доставание со стейта в разных местах кода внутри `mapStateToProps`. Достаточно будет внести эти изменения внутри самой функции-селектора.

## Зачем нужна библиотека `reselect`?

Селекторы сами по себе имеют несколько недостатков. Дело в том, что функция `mapStateToProps` запускается постоянно при любых изменениях в стейте, при этом перерисовка без применения селекторов (при доставании данных прямо со стейта) не происходит, если ничего не поменялось из тех объектов, на которые мы подписались внутри `mapStateToProps`. Так и должно быть. Но вот в случае использования селекторов перерисовка происходит постоянно при каждом запуске `mapStateToProps`, даже если наши конкретные изначальные объекты в стейте не поменялись (точнее не создались их копии), ведь функция возвращает каждый раз новый объект.

В итоге постоянный рендеринг создает дополнительную нагрузку. Но даже это не самое страшное, особенно если селекторые простые и не производят каких-то очень сложных вычеслений. А хуже всего в этом то, что в таких условиях невозможно будет дебажить, так как дебагер будет постоянно срабатывать.

Поэтому библоитека `reselect` и применяется, чтобы создавать криэйт-селекторы, задавая в качестве первых параметров простой селектор (или несколько селекторов) и следя за изменением возвращаемых ими значений, сравнивая их с кэшированными. По сути происходит то же, что до этого нам делал `mapStateToProps`, только не с самим стейтом, а возвращаемыми селекторами значениями. В итоге `reselect` позволяет делать перерисовку и запускать более сложные расчеты только тогда, когда значение простого селектора изменилось. Подписываться внутри одного такого криэйт-селектора сразу можно на несколько селекторов, в результате чего перерисовка будет происходить при изменении в значения в любом из них.

---

```javascript
const filteredHeroesSelector = createSelector(
	(state) => state.filters.activeFilter,
	(state) => state.heroes.heroes,
	(filter, heroes) => {
		if (filter === 'all') {
			return heroes;
		} else {
			return heroes.filter((item) => item.element === filter);
		}
	}
);

const filteredHeroes = useSelector(filteredHeroesSelector);
```

---

## Ссылки

- reselect
  - https://github.com/reduxjs/reselect
- combineReducers(reducers)
  - https://redux.js.org/api/combinereducers
- код из урока
  - https://github.com/yankovalenko94/JS_task_answers/tree/master/React_Redux_step_30
- Селекторы и библотека reselect
  - https://it-shpora.pp.ua/%D1%81%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D0%B1%D0%B8%D0%B1%D0%BB%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-reselect/

```

```

# 212. ❗️ Redux Toolkit; RTK Query

## Обзор RTK-запросов

**RTK Query** — мощный инструмент извлечения и кэширования данных. Он предназначен для упрощения распространенных случаев загрузки данных в веб-приложение, **устраняя необходимость самостоятельно писать логику выборки и кэширования данных.**

RTK Query — это **дополнительная надстройка, включенная в пакет Redux Toolkit**, и ее функциональность построена поверх других API в Redux Toolkit.

> ИНФОРМАЦИЯ
>
> Чтобы узнать, как использовать RTK-Query, см. полное [руководство «Redux Essentials»](https://redux.js.org/tutorials/essentials/part-7-rtk-query-basics) на сайте основной документации Redux.

## Мотивация

Веб-приложениям обычно необходимо получать данные с сервера для их отображения. Им также обычно необходимо обновлять эти данные, отправлять эти обновления на сервер и синхронизировать кэшированные данные на клиенте с данными на сервере. Это усложняется необходимостью реализации других вариантов поведения, используемых в современных приложениях:

- Отслеживание состояния загрузки для отображения UI spinners.
- Как избежать дублирования запросов на одни и те же данные
- Оптимистичные обновления, ускоряющие работу пользовательского интерфейса.
- Управление временем жизни кэша при взаимодействии пользователя с пользовательским интерфейсом.

Ядро Redux всегда было очень минимальным — разработчики должны писать всю реальную логику. Это означает, что Redux никогда не включал в себя ничего встроенного, помогающего решить эти варианты использования. В документации Redux описаны некоторые общие шаблоны диспетчеризации действий на протяжении жизненного цикла запроса для отслеживания состояния загрузки и результатов запроса , а API Redux Toolkit `createAsyncThunk` был разработан для абстрагирования этого типичного шаблона. Однако пользователям по-прежнему приходится писать значительный объем логики редуктора для управления состоянием загрузки и кэшированными данными.

За последние пару лет сообщество React пришло к пониманию того, что **«извлечение и кэширование данных» на самом деле представляет собой другой набор проблем, чем «управление состоянием»**. Хотя вы можете использовать библиотеку управления состоянием, такую ​​как Redux, для кэширования данных, варианты использования достаточно различны, поэтому стоит использовать инструменты, специально созданные для варианта использования выборки данных.

RTK Query черпает вдохновение из других инструментов, которые стали пионерами в решениях для извлечения данных, таких как Apollo Client, React Query, Urql и SWR, но добавляет уникальный подход к дизайну своего API:

- Логика выборки и кэширования данных построена на основе Redux Toolkit `createSliceи` `createAsyncThunk` API.
- Поскольку Redux Toolkit не зависит от пользовательского интерфейса, функциональность RTK Query можно использовать с любым слоем пользовательского интерфейса.
- Конечные точки API определяются заранее, включая способы генерации параметров запроса на основе аргументов и преобразования ответов для кэширования.
- RTK Query также может генерировать перехватчики React, которые инкапсулируют весь процесс извлечения данных, предоставляют `data` поля `isLoading` компонентам и управляют временем жизни кэшированных данных при монтировании и отключении компонентов.
- RTK Query предоставляет параметры «жизненного цикла записи в кэше», которые позволяют использовать такие варианты использования, как потоковая передача обновлений кэша через сообщения веб-сокета после получения исходных данных.
- У нас есть ранние рабочие примеры генерации кода срезов API из схем OpenAPI и GraphQL.
- Наконец, RTK Query полностью написан на TypeScript и обеспечивает удобство использования TS.

## RTK Query включен в установку основного пакета Redux Toolkit.

Он доступен через любую из двух точек входа ниже:

```js
import { createApi } from '@reduxjs/toolkit/query';

/* Точка входа, специфичная для React, которая автоматически 
генерирует хуки, соответствующие определенным конечным точкам */
import { createApi } from '@reduxjs/toolkit/query/react';
```

RTK Query включает в себя следующие API:

- `createApi()`: ядро ​​функциональности RTK Query. Он позволяет вам определить набор конечных точек, описывающих, как получать данные из ряда конечных точек, включая настройку способа получения и преобразования этих данных. В большинстве случаев вам следует использовать это один раз для каждого приложения, используя, как правило, «один фрагмент API на каждый базовый URL».
- `fetchBaseQuery()`: Небольшая оболочка, `fetch` призванная упростить запросы. Предназначен как рекомендуемый `baseQuery` для использования `createApi` большинством пользователей.
- `<ApiProvider />`: Может использоваться как `Provider` **если у вас еще нет Redux `store`**.
- `setupListeners()`: Утилита, используемая для включения `refetchOnMount` и `refetchOnReconnect` поведения.

## Basic Usage

### Create an API Slice

RTK Query включен в установку основного пакета Redux Toolkit. Он доступен через любую из двух точек входа ниже:

```js
import { createApi } from '@reduxjs/toolkit/query';

/* Точка входа, специфичная для React, которая автоматически 
генерирует хуки, соответствующие определенным конечным точкам */
import { createApi } from '@reduxjs/toolkit/query/react';
```

Для типичного использования React начните с импорта `createApi` и определения «API slice», в котором указан базовый URL-адрес сервера и конечные точки, с которыми мы хотим взаимодействовать:

```js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
import type { Pokemon } from './types'

// Define a service using a base URL and expected endpoints
export const pokemonApi = createApi({
  reducerPath: 'pokemonApi',
  baseQuery: fetchBaseQuery({ baseUrl: 'https://pokeapi.co/api/v2/' }),
  endpoints: (builder) => ({
    getPokemonByName: builder.query<Pokemon, string>({
      query: (name) => `pokemon/${name}`,
    }),
  }),
})

// Экспортируем хуки для использования в функциональных компонентах, которые
// генерируется автоматически на основе определенных конечных точек
export const { useGetPokemonByNameQuery } = pokemonApi
```

### Configure the Store

«API slice» также содержит автоматически создаваемый Redux slice reducer и настраиваемое middleware, которое управляет сроком действия подписки. Оба из них необходимо добавить в хранилище Redux:

```js
import { configureStore } from '@reduxjs/toolkit';
// Or from '@reduxjs/toolkit/query/react'
import { setupListeners } from '@reduxjs/toolkit/query';
import { pokemonApi } from './services/pokemon';

export const store = configureStore({
	reducer: {
		// Add the generated reducer as a specific top-level slice
		// Добавьте сгенерированный редуктор в качестве определенного верхнего уровня.
		[pokemonApi.reducerPath]: pokemonApi.reducer,
	},
	// Adding the api middleware enables caching, invalidation, polling,
	// and other useful features of `rtk-query`.
	// Добавление api middleware позволяет кэшировать, делать недействительными, опросить,
	// и другие полезные возможности `rtk-query`.
	middleware: (getDefaultMiddleware) =>
		getDefaultMiddleware().concat(pokemonApi.middleware),
});

// optional, but required for refetchOnFocus/refetchOnReconnect behaviors
// see `setupListeners` docs - takes an optional callback as the 2nd arg for customization
// необязательно, но необходимо для поведения refetchOnFocus/refetchOnReconnect
// см. документацию `setupListeners` — принимает необязательный обратный вызов в качестве второго аргумента для настройки
setupListeners(store.dispatch);
```

### Use Hooks in Components

Наконец, импортируйте автоматически сгенерированные перехватчики React из API slice в файл компонента и вызывайте hooks в своем компоненте с любыми необходимыми параметрами. RTK Query будет автоматически получать данные при монтировании, повторно получать данные при изменении параметров, предоставлять `{data, isFetching}` значения в результате и повторно отображать компонент при изменении этих значений:

```js
import * as React from 'react';
import { useGetPokemonByNameQuery } from './services/pokemon';

export default function App() {
	// Using a query hook automatically fetches data and returns query values
	// Использование перехватчика запроса автоматически извлекает данные и возвращает значения запроса
	const { data, error, isLoading } = useGetPokemonByNameQuery('bulbasaur');
	// Individual hooks are also accessible under the generated endpoints:
	// Отдельные хуки также доступны под сгенерированными конечными точками:
	// const { data, error, isLoading } = pokemonApi.endpoints.getPokemonByName.useQuery('bulbasaur')

	// render UI based on data and loading state
	// рендеринг пользовательского интерфейса на основе данных и состояния загрузки
}
```

---

---

**`src/api/apiSlice.js`**

```js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const apiSlice = createApi({
	// данные будут в store.api
	reducerPath: 'api',
	baseQuery: fetchBaseQuery({ baseUrl: 'http://localhost:3001' }),
	tagTypes: ['Heroes'],
	endpoints: (builder) => ({
		getHeroes: builder.query({
			query: () => '/heroes',
			providesTags: ['Heroes'],
		}),
		createHero: builder.mutation({
			query: (hero) => ({
				url: '/heroes',
				method: 'POST',
				body: hero,
			}),
			invalidatesTags: ['Heroes'],
		}),
		deleteHero: builder.mutation({
			query: (id) => ({
				url: `/heroes/${id}`,
				method: 'DELETE',
			}),
			invalidatesTags: ['Heroes'],
		}),
	}),
});

export const {
	useGetHeroesQuery,
	useCreateHeroMutation,
	useDeleteHeroMutation,
} = apiSlice;
```

**`src/store/store.js`**

```js
import { configureStore } from '@reduxjs/toolkit';

// убрали heroesSlice
import filtersReducer from '../slices/filtersSlice';
import { apiSlice } from '../api/apiSlice';

const stringMiddleware = () => (next) => (action) => {
	// ...
};

const store = configureStore({
	reducer: {
		// убрали heroes
		filters: filtersReducer,
		[apiSlice.reducerPath]: apiSlice.reducer,
	},
	middleware: (getDefaultMiddleware) => {
		return getDefaultMiddleware().concat(stringMiddleware, apiSlice.middleware);
	},
	devTools: process.env.NODE_ENV !== 'production',
});

export default store;
```

**`src/components/heroesAddForm/HeroesAddForm.js`**

```js
// ...
import { useCreateHeroMutation } from '../../api/apiSlice';
const HeroesAddForm = () => {
	const [createHero, { isLoading, isError }] = useCreateHeroMutation();

	const filtersLoadingStatus = useSelector(
		(state) => state.filters.loadingStatus
	);
	const filters = useSelector(allFiltersSelector);
	// ...
	const onSubmitHandler = (e) => {
		e.preventDefault();
		const newHero = {
			id: uuidv4(),
			name: heroName,
			description: heroDescr,
			element: heroElement,
		};
		createHero(newHero).unwrap();
	};

	const renderFilters = (filters, status) => {
		if (isLoading) {
			return <option>Загрузка элементов</option>;
		} else if (isError) {
			return null; // <option>Ошибка загрузки</option>;
		}
		// ...
	};
	return (
		<form className='border p-4 shadow-lg rounded' onSubmit={onSubmitHandler}>
			// ...
			<select
				required
				className='form-select'
				id='element'
				name='element'
				value={heroElement}
				onChange={(e) => setHeroElement(e.target.value)}
			>
				<option value=''>Я владею элементом...</option>
				{renderFilters(filters, filtersLoadingStatus)}
			</select>
			// ...
		</form>
	);
};
```

**`src/components/heroesList/HeroesList.js`**

```js
// ...
import { useGetHeroesQuery, useDeleteHeroMutation } from '../../api/apiSlice';

const HeroesList = () => {
	const { data: heroes = [], isLoading, isError } = useGetHeroesQuery();
	const [deleteHero] = useDeleteHeroMutation();

	const activeFilter = useSelector((state) => state.filters.activeFilter);
	const filteredHeroes = useMemo(() => {
		// сделать копию массива heroes
		const vHeroes = heroes.slice();

		if (activeFilter === 'all') {
			return vHeroes;
		} else {
			return vHeroes.filter((item) => item.element === activeFilter);
		}
	}, [activeFilter, heroes]);

	const onDelete = (id) => {
		deleteHero(id);
	};

	if (isLoading) {
		return <Spinner />;
	} else if (isError) {
		return <h5 className='text-center mt-5'>Ошибка загрузки</h5>;
	}
	const renderHeroesList = (arr = []) => {
		if (arr.length === 0) {
			return (
				<CSSTransition timeout={0} classNames='hero'>
					<h5 className='text-center mt-5'>Героев пока нет</h5>
				</CSSTransition>
			);
		}

		return arr.map(({ id, ...props }) => {
			return (
				<CSSTransition key={id} timeout={500} classNames='hero'>
					<HeroesListItem {...props} onDelete={() => onDelete(id)} />
				</CSSTransition>
			);
		});
	};

	const elements = renderHeroesList(filteredHeroes);
	return <TransitionGroup component='ul'>{elements}</TransitionGroup>;
};

export default HeroesList;
```

---

## Ссылки

- RTK Query - Официальная документация
  - https://redux-toolkit.js.org/rtk-query/overview
- react-query
  - https://tanstack.com/query/v3/
- Код из урока
  - https://github.com/yankovalenko94/JS_task_answers/tree/master/React_Redux_step_38

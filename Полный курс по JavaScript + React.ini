[end]
25

[06 (д) Eslint. Подсказки об ошибках и автоматическое форматирование кода]
18:33 = инициализация Eslint в каждом новом проекте:
	> npm init
	yes на все вопросы
	> npm init @eslint/config
	команда инициализации со страницы 
	https://eslint.org/docs/latest/use/getting-started
	параграф "Quick start"
18:47 = перенастройка ".eslintrc.js"
	автоформатирование при сохранении

[007. Что такое JS и как его подключить к странице]
включение в HTML:
	<script>...</script>
	<script src="..."></script>
! так не работает:
	<script src="..." />
	
08:45 = script подключается в самом конце html-файла, перед </body>
	это необходимо чтобы:
	1. страница загружается последовательно и если скрипт загрузится и начнёт работу раньше, чем браузер
		отпарсит какой-то элемент, с которым взаимодействует скрипт, то скрипту не с чем будет работать.
	2. страница загружается последовательно и если скрипт грузится медленно (с медленного сервера 
		или вообще не может загрузиться), то страница в браузере перестанет загружаться "зависнет".
	
	Современный учебник JavaScript
	https://learn.javascript.ru/
	
	CSS3-селекторы
	https://learn.javascript.ru/css-selectors
	
	Введение в HTML
	https://developer.mozilla.org/ru/docs/Learn/HTML/Introduction_to_HTML
	
	Введение в CSS
	https://developer.mozilla.org/ru/docs/Learn/CSS/First_steps
	
[009. Переменные и строгий режим]
00:51 =	объявление переменной
	let
	const
05:40 = особенность const: внутри объекта-const можно менять значения переменных.
07:05 = проблемы устаревшего объявления переменной через "var"
09:40 = область видимости let/const/var
11:10 = caniuse.com = проверка поддержки элементов JS в разных браузерах
12:20 = Строгий режим — "use strict" - директива
14:15 = стилистические правила JS

[010. (д) Правила и типы названия переменных]
	переменные, имеющие логический смысл называть осмысленно:
	let carBobyLength

	переменные в логических блоках называть как хочешь:
	for (let i=0; i<10; i++){};
	[111, 222, 123].map( a => ... );

	константы называть большими буквами через подчёркивание:
	const UPPER_SNAKE_KASE
	или как переменные со смыслом, но начинающиеся с подчёркивания:
	const _apiKey = 'apiKey=85139450398570198345';

[011. Классификация типов данных в JavaScript]
	простые типы:
		числа ( (-(2^53)-1)..((2^53)-1) ): 1, 2, ...
		строки: 'string', 'name John'
		логический (boolean): true/false
		null (чего-то не существует)
		undefined (значение не определено)
		Symbol
		BigInt (большие ЦЕЛЫЕ числа. больше, чем "числа" )
объекты:
		специальные:
			массивы: []
			функции: function ...
			объект даты:
			регулярные выражения:
			ошибки:
		определённые нами:
			const obj = {
				name: 'John',
				age: 25,
				isMarried: false
			};

[012. (д) Разница между объектами и массивами и неочевидные синтаксические возможности]
[013. Простое общение с пользователем]
00:38 = alert('текст'); 
	= всплывающее сообщение с текстом
02:12 = const res = confirm('текст'); 
	= всплывающее сообщение с текстом и вариантом выбора кнопами Ok/Cancel
04:12 = const res = prompt('текст', 'ответ по умолчанию. может быть пустой'); 
	= всплывающее сообщение с текстом и вариантом ввода значения и кнопами Ok/Cancel
06:01 = typeof(res)
06:55 = const res = +prompt(...
	= возвращаемый результат будет числовой
10:59 = document.write(_текст_);
	= заменяет текст на странице на _текст_

[014. Интерполяция (ES6)]
[015. Операторы в JS]
01:45 = конкатенация строк:
	4 +  '5' = '45'
	4 + +'5' = 9
	4 + +'5s' = NaN // Not A Number
	если слева от строки поставить знак '+', то строка будет интерпретирована в число
	
	префикс/постфикс форма инкремент/декремент переменных
	++i, i++
	--i, i--
	
06:01 =	% - остаток от деления // 5%2 = 1
06:42 = использование знака "="
	"=" - присвоить 
	"==" - сравнение (по значению)
		2*4 == 8   // true
		2*4 == '8' // true
	"===" - строгое сравнение (по значению и типу)
		2*4 === 8   // true
		2*4 === '8' // false
08:14 = лигические операторы
	&& = И
	|| = ИЛИ
	!  = НЕ '!=', '!=='
// приоритет операторов
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table

// Побитовые операторы
// https://learn.javascript.ru/bitwise-operators

[016. Учимся работать с системой контроля версий Git и с сервисом GitHub]
08:00 = git init
10:32 = git config --global ...
12:10 = git add
12:26 = git status
14:05 = git commit
16:01 = git log
19:11 = git push // отправить изменения в удалённый репозиторий
21:25 = git branch -M main // переименовать текущую ветку в  'main'

[Git - дополнительные материалы]
'githowto.com/ru'
	11. Алиасы
		git config --global alias.co checkout
		git config --global alias.ci commit
		git config --global alias.st status
		git config --global alias.br branch
		git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"
		git config --global alias.hista "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short --all"
		git config --global alias.type 'cat-file -t'
		git config --global alias.dump 'cat-file -p'
	12. checkout <version> - перейти к определённой версии проекта. все файлы проекта станут как в версии <version>
		git checkout <hash> // переключиться на ветку с хэшем <hash>
		git checkout master // переключиться на последний коммит ветки 'master'
	31. Сброс ветки
		использовать команду reset для возврата веток к предыдущему состоянию
		git reset --hard <hash>

'git-scm.com'
	Книга по Git
	https://git-scm.com/book/ru/v2/
	3.2 Ветвление в Git - Основы ветвления и слияния
	https://git-scm.com/book/ru/v2/Ветвление-в-Git-Основы-ветвления-и-слияния
	3.3 Ветвление в Git - Управление ветками
	https://git-scm.com/book/ru/v2/Ветвление-в-Git-Управление-ветками

[017. Как работать с GitHub с разных компьютеров, gitignore и Git Kraken]
07:01 = ошибка новичка: после внесения изменений в проект на GitHub, попытка выгрузить изменения локального репозитория
	'git push'
	вызовет ошибку. требуется сначала загрузить изменения из удалённого репозитория
	'git pull'
	и только после этого выгружать локальный.

[019. Практика, ч.1. Начинаем создавать приложение]
[020. Условия]
	https://learn.javascript.ru/ifelse
04:52 = if () {} else if () {}
05:49 = Условный (тернарный) оператор:

	(var === 10) ? console.log('TRUE') : console.log('FALSE');

	let var = (age > 18) ? true : false;

	let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 99) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

08:27 = switch
	всегда производится строгое (===) сравнение!
	https://learn.javascript.ru/switch

	switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    break;

  case 'value2':  // if (x === 'value2')
    ...
    break;

  default:
    ...
    break;
	}

[021. (д) Логические операторы]
19:30 = оператор И '&&' всегда возвращает первое ложное значение, если оно есть.
	если все условия true, то возвращается значение последнего аргумента.
	console.log(1 && 0);     // 0
	console.log(1 && 5);     // 5
	console.log(null && 5);  // null
	console.log(0 && 'abc'); // 0
	console.log(1 && 'abc'); // 'abc'

21:53 = оператор ИЛИ '||' возвращает первое true значение, если оно есть.
	если все условия false, то возвращается значение последнего аргумента.
	console.log(1 || 0);     // 1
	console.log(0 || 0);     // 0
	console.log(0 || false); // false
	console.log(1 || 5);     // 1
	console.log(null || 5);  // 5
	console.log(0 || 'abc'); // 'abc'
	console.log(1 || 'abc'); // 1

const arr = [ 0, '0', 1, '1', true, 'true', false, 'false', null, NaN, undefined, {}, [], '', ' ', '_' ];

arr.map(val => {
	console.log('>',val,`<\t\t(${ typeof(val) })\t\t= ${ (val)?true:false }`, '\t\t=> ', (true && val) );
});
; > 0 <		(number)		= false 		=>  0
; > 0 <		(string)		= true 		=>  0
; > 1 <		(number)		= true 		=>  1
; > 1 <		(string)		= true 		=>  1
; > true <		(boolean)		= true 		=>  true
; > true <		(string)		= true 		=>  true
; > false <		(boolean)		= false 		=>  false
; > false <		(string)		= true 		=>  false
; > null <		(object)		= false 		=>  null
; > NaN <		(number)		= false 		=>  NaN
; > undefined <		(undefined)		= false 		=>  undefined
; > {} <		(object)		= true 		=>  {}
; > [] <		(object)		= true 		=>  []
; >  <		(string)		= false 		=>  
; >   <		(string)		= true 		=>   
; > _ <		(string)		= true 		=>  _

arr.map(val => {
	console.log('! >',val,`<\t\t(${ typeof(val) })\t\t= ${ (!val)?true:false }`, '\t\t=> ', (true && !val) );
});
; ! > 0 <		(number)		= true 		=>  true
; ! > 0 <		(string)		= false 		=>  false
; ! > 1 <		(number)		= false 		=>  false
; ! > 1 <		(string)		= false 		=>  false
; ! > true <		(boolean)		= false 		=>  false
; ! > true <		(string)		= false 		=>  false
; ! > false <		(boolean)		= true 		=>  true
; ! > false <		(string)		= false 		=>  false
; ! > null <		(object)		= true 		=>  true
; ! > NaN <		(number)		= true 		=>  true
; ! > undefined <		(undefined)		= true 		=>  true
; ! > {} <		(object)		= false 		=>  false
; ! > [] <		(object)		= false 		=>  false
; ! >  <		(string)		= true 		=>  true
; ! >   <		(string)		= false 		=>  false
; ! > _ <		(string)		= false 		=>  false

32:39 = задачи
console.log('> что выведет в консоль код?');
console.log(NaN || 2 || undefined              , 2     );
console.log(NaN && 2 & undefined               , NaN   );
console.log(1 && 2 && 3                        , 3     );
console.log(!1 && 2 && !3                      , false );
console.log(25 || null && !3                   , 25    );
console.log(NaN || null || !3 || undefined || 5, 5     );
console.log(NaN || null && !3 && undefined || 5, 5     );
console.log( 5===5 && 3 > 1 || 5               , true  );

[022. Циклы]
	1. while( условие ){}
	2. do {} while ( условие );
	3. for(let j=30; условие; j++){ continue; ...; } // прервать итерацию цикла
	4. for(let j=40; условие;){ j++;}
	5. for(let j=50;;){ ...; j++; break; } // прервать работу цикл

	continue - пропустить итерацию цикла.
	break - прервать цикл.

[023. (д) Цикл в цикле и метки]
14:55 = метки в циклах: continue - прервать итерацию
	label1: for (let i1=0;i1<3; i1++){
		for (let i3=0; i3<3; i3++) {
			if (i3 ===2) continue label1;
	}}

15:58 = метки в циклах: break - прервать работу
	label1: for (let i1=0;i1<3; i1++){
		for (let i3=0; i3<3; i3++) {
			if (i3 ===2) break label1;
		}
	}

[024. Практика, ч2. Применяем условия и циклы]

[025. Функции, стрелочные ф-ции (ES6)]
14:16 = {
		function declaration:
		function foo(){}
		Создаётся до начала выполнения скрипта, можно вызвать перед объявлением.

		function expression:
		let foo = function(){}
		Создаётся только тогда, когда доходит поток кода, можно вызвать только после объявления.
	}
	стрелочные функции: {
		()=>
		Не имеет своего контекста (this).
		пример:
		'const calc = (a,b) => a+b;'
		'const calc = (a,b) => { return a+b; };'
		'const calc = a => a*2;'

		Синтаксис
		=========
		Базовый синтаксис:
		(param1, param2, …, paramN) => { statements }
		(param1, param2, …, paramN) => expression
		// эквивалентно: '(param1, param2, …, paramN) => { return expression; }'

		// Круглые скобки не обязательны для единственного параметра:
		(singleParam) => { statements }
		singleParam => { statements }

		// Функция без параметров нуждается в круглых скобках:
		() => { statements }
		() => expression
		// Эквивалентно: '() => { return expression; }'

		Расширенный синтаксис:
		// Когда возвращаете литеральное выражение объекта, заключите тело в скобки
		params => ({foo: bar})
		'var func = () => { foo: 1 }; // Вызов func() возвращает undefined!'

		// Остаточные параметры и параметры по умолчанию поддерживаются
		(param1, param2, ...rest) => { statements }
		(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }

		// Деструктуризация тоже поддерживается
		var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
		'f();'  // 6
	}
	{
		! работает только в браузере !
		Синтаксис "new Function":
		=========================
		let func = new Function([arg1, arg2, ...argN], functionBody);
		Функция создаётся с заданными аргументами arg1...argN и телом functionBody.
		
		Это проще понять на конкретном примере. Здесь объявлена функция с двумя аргументами:
		let sum = new Function('a', 'b', 'return a + b');
		alert( sum(1, 2) ); // 3

		А вот функция без аргументов, в этом случае достаточно указать только тело:
		let sayHi = new Function('alert("Hello")');
		sayHi(); // Hello
		
			Главное отличие от других способов объявления функции, которые были рассмотрены ранее, заключается в том, 
		что функция создаётся полностью «на лету» из строки, переданной во время выполнения.
			Обычно функция запоминает, где родилась, в специальном свойстве [[Environment]]. 
		Это ссылка на лексическое окружение (Lexical Environment), в котором она создана (мы разбирали это в главе Замыкание).
		Но когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее 
		лексическое окружение, в котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к 
		глобальным переменным.
	}
	{
		//	замыкание:
		//		создаётся новый экземпляр "createCounter.counter" из области "область_2" при создании экземпляра "myFunction"
		//	на этот экземпляр "createCounter.counter" создаётся замыкание.
		//		это похоже на создание экземпляра класса "createCounter", имеющего переменную "counter"
		//	и при каждом создании "const переменная = createCounter();" создаётся новый экземпляр класса "createCounter".
		//		замыкание происходит в случае, если при выходе из области объявления становятся недоступными переменные, 
		//	использующиеся внутри объявления фукции.
		//
		{ // область "область_1"
			let counter = 10;
			function createCounter() { // область "область_2"
				let counter = 20;
				const myFunction = function() {
					counter = counter + 1;
					return counter;
				};
				return myFunction;
			}
			const inc1 = createCounter();
			const c11 = inc1();
			const c12 = inc1();
			const c13 = inc1();
			console.log('c1*:', c11, c12, c13);
			const inc2 = createCounter();
			const c21 = inc2();
			const c22 = inc2();
			console.log('c2*:', c21, c22);
			console.log('counter', counter);
		}
		/* результат:
		c1*: 21 22 23
		c2*: 21 22
		counter 10
		*/
		// =================================================================
		//	НЕ замыкание:
		//		создаётся ССЫЛКА на экземпляр "counter" из области "область_1" при создании экземпляра "myFunction"
		//	( ближайшая предыдущая относительно "const myFunction = function() {" область, 
		//	в которой присутствует переменная "counter" ).
		//		при каждом создании экземпляра "const myFunction = function() {"
		//	ссылается на один и тот же экземпляр "counter" из области "область_1".
		//
		{ // область "область_1"
			let counter = 10;
			function createCounter() { // область "область_2"
				//let counter = 20;
				const myFunction = function() {
					counter = counter + 1;
					return counter;
				};
				return myFunction;
			}
			const inc1 = createCounter();
			const c11 = inc1();
			const c12 = inc1();
			const c13 = inc1();
			console.log('c1*:', c11, c12, c13);
			const inc2 = createCounter();
			const c21 = inc2();
			const c22 = inc2();
			console.log('c2*:', c21, c22);
			console.log('counter', counter);
		}
		/* результат:
		c1*: 11 12 13
		c2*: 14 15
		counter 15
		*/
	}
	{
		// 025_31
		// пример того, что создаётся ссылка на имеющийся экземпляр переменной "getCounter.counter"
		'use strict';

		function getCounter(){
			let counter = 10;

			const fCnr1 = ()=> ++counter;
			const fCnr2 = ()=> ++counter;

			return {fCnr1, fCnr2};
		}

		{
			const fInc_1 = getCounter();
			const inc_11 = fInc_1.fCnr1;
			const inc_12 = fInc_1.fCnr2;

			const c1_11 = inc_11(); // 11
			const c1_12 = inc_11(); // 12
			const c1_21 = inc_12(); // 13
			const c1_13 = inc_11(); // 14
			const c1_22 = inc_12(); // 15

			console.log('c1_1*:', c1_11, c1_12, c1_13);
			console.log('c1_2*:', c1_21, c1_22);
		}
		{
			const fInc_2 = getCounter();
			const inc_21 = fInc_2.fCnr1;
			const inc_22 = fInc_2.fCnr2;
			const c2_11 = inc_21(); // 11
			const c2_12 = inc_21(); // 12
			const c2_21 = inc_22(); // 13
			const c2_13 = inc_21(); // 14
			const c2_22 = inc_22(); // 15

			console.log('c2_1*:', c2_11, c2_12, c2_13);
			console.log('c2_2*:', c2_21, c2_22);
		}
		/* результат:
		c1_1*: 11 12 14
		c1_2*: 13 15
		c2_1*: 11 12 14
		c2_2*: 13 15
		*/
	}
	{
		замыкание
		https://learn.javascript.ru/closure

		Лексическое Окружение:
		Чтобы понять, что происходит, давайте для начала обсудим, что такое «переменная» на самом деле.
		В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний 
		(скрытый) объект, называемый лексическим окружением LexicalEnvironment.
		Объект лексического окружения состоит из двух частей:
			1. Environment Record – объект, в котором как свойства хранятся все локальные переменные 
				(а также некоторая другая информация, такая как значение this).
			2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи 
				(снаружи от текущих фигурных скобок).
		"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. 
		«Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

		Итого:
    * Переменная – это свойство специального внутреннего объекта, связанного с текущим 
				выполняющимся блоком/функцией/скриптом.
    * Работа с переменными – это на самом деле работа со свойствами этого объекта.

		Внутреннее и внешнее лексическое окружение:
			При запуске функции для неё автоматически создаётся новое лексическое окружение, 
		для хранения локальных переменных и параметров вызова.
			Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем 
		лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.
			Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, 
		для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную 
		переменную с таким именем.

		"информация":
		Один вызов – одно лексическое окружение:
			Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, 
		когда функция выполняется.
			И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, 
		со своими, специфичными для этого вызова, локальными переменными и параметрами.

		"информация":
		Лексическое окружение – это специальный внутренний объект:
			«Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем 
		коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые 
		переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта 
		должно оставаться таким, как было описано.
	}
